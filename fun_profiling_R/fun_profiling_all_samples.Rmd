---
title: "Funtional profiling (Metawibele)"
author: "Miguel Parra"
date: "2022-11-07"
output: html_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#Import libraries
library ("ggplot2")
library("readr")

library ("tidyr")
library ("ggrepel")
library ("purrr")
library ("vegan")
library ("ape")
library ("compositions")
#library ("robcompositions")
library ("ggfortify")
library ("edgeR")
library ("forcats")
library ("ggsci")
library ("umap")
library ("ggpointdensity")
library ("tibble")

library ("topGO")
library("dplyr")
library ("ggpubr")
library ("edgeR")
library ("Maaslin2")
library ("janitor")
library ("stringr")
library("KEGGREST")


```


##Loading the data


### Characterization outputs:
```{r}
### Characterize outputs: 
annotation <- read_tsv("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/metawibele_proteinfamilies_annotation.tsv")
annotation_attribute <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/proteinfamilies_annotation.attribute_2.tsv") #Supplements the annotation information
annotation_attribute <- annotation_attribute %>% rename (category = anotation)

#annotation_attribute <- annotation_attribute %>% separate (col = AID, into = c ("familyID", "category"), sep = "__") # This takes long...
abundance_prot_families <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/metawibele_proteinfamilies_nrm.tsv")
abundance_prot_families <- abundance_prot_families %>% rename (familyID = ID)


```

DRUP metadata
```{r}
drup_metadata <- read_csv ("/DATA/share/tom_masters/miguel/drup-gut-metadata.csv")
final_metadata <- read_csv ("./filtered-metadata.csv")
```
```{r}
#Remove the samples that should be excluded (MSS, missing response, ...)
abundance_prot_families <- abundance_prot_families %>% select (-setdiff( (abundance_prot_families %>% select (contains ("DRUP")) %>% colnames()), final_metadata$Sample))
```


Path for saving the plots
```{r}
path_plots <- "/home/m.p.martinez/fun_profiling/plots/metawibele/run2"
```


Rename oesophagus cancer
```{r}
final_metadata <- final_metadata %>% mutate (tumor_type = replace (tumor_type, tumor_type %in% c ("Oesphagus cancer", "Oesophaghus cancer"), "Oesophagus cancer" ))

```





##Exploratory data analysis. 

```{r}
#Number of protein clusters: 
n_clusters <- n_distinct (annotation$familyID) #2659982

#Mean number of proteins that form the clusters
# 1.21 Most of the clusters are composed of only 1 predicted protein. 
annotation_attribute %>% filter (key == "cluster_size") %>% mutate (value = as.numeric(value)) %>% summarise(mean = mean(value), sd = sd(value), min = min(value), max(value), n = n())

annotation_attribute %>% filter (key == "cluster_size") %>% mutate (value = as.numeric (value)) %>% filter (value == 1) %>% nrow() /n_clusters

annotation %>% distinct(method) %>% pull()

```
Most of the clusters (87%) are formed by 1 protein only. In line with Metawibele publication (2023587 predicted proteins in origin)


### Taxonomy annotation
```{r}
annotation_taxonomy <- annotation %>% filter (method == "Taxonomy_annotation")

annotation_taxonomy  %>% group_by (feature) %>% summarise (n = n(), freq = n()/n_clusters)

annotation_taxonomy  %>% 
  ggplot (aes (feature)) + geom_bar(aes (fill = feature), show.legend = FALSE) + scale_y_log10() + labs (y = "log(No.) of proteins families", x = "Taxonomic classification")

annotation_taxonomy %>% filter (feature == "Unclassified") %>% nrow() / n_clusters


## Most of the predicted proteins are unclassified 
```
Most of the predicted proteins are unclassified. (95%)

This contrast with the paper of metawibele which shows that most of the proteins can be taxonomically classified. 

###Pangenomes
```{r}
#Number of pangenomes predicted by MSPminer 
annotation %>% filter (method == "MSPminer") %>% select (annotation) %>% distinct() %>% dim() # 1253

#Number of protein families that are forming part of a pangenome
annotation %>% filter (method == "MSPminer") %>% filter (annotation != "msp_unknown") %>%
  group_by(method) %>% summarise (n_clusters = n(), per_clusters = round (n()/ n_clusters * 100, 3)) #31,42 % of the protein families belong to a pangenome... 

#Distribution of number of protein families forming each mspminer pangenome
annotation %>% filter (method == "MSPminer") %>% filter (annotation != "msp_unknown") %>% group_by(annotation) %>% summarise(n = n()) %>% 
  ggplot(aes (x = n)) + geom_histogram (aes( fill = "#D16103" ), show.legend = FALSE)

```

1253 is the number of pangenomes generated by MSP miner. But 835,092 different protein clusters form part of these pangenomes



### Homology
```{r}
annotation_uniref <- annotation %>% filter (method == "UniRef90") %>% select (-c (method,AID))
annotation_uniref %>% head()

annotation_uniref %>% filter (category == "UniRef90_characterization") %>% ggplot (aes (feature)) + geom_bar() + coord_flip()



annotation_uniref %>% filter (category == "UniRef90_homology") %>% group_by(feature) %>% summarise(count = n())
annotation_uniref %>% filter (category == "UniRef90_homology") %>%
  ggplot (aes (feature)) + geom_bar(aes (fill = feature), show.legend = FALSE) +
  labs (x = " Homology against UniRef90", y = "No. of protein families") +
  scale_fill_manual (values = c ("#52854C", "#4E84C4", "#D16103"))

annotation_uniref %>% filter (category == "UniRef90_homology") %>% group_by (feature) %>% summarise( count = n(), percentage = n()/n_clusters)
#Most of the proteins have a strong uniref90 homology. 

```
Most of the proteins have a strong uniref90 homology.



```{r}

#Homology and abundance analysis. 
homology_abun_per_sample <- annotation_uniref %>% filter (category == "UniRef90_homology") %>% select (familyID, feature) %>% left_join(abundance_prot_families)

#Merge the two homology classifications. Strong homology = uniref90 characterize + uncharacterized. 
homology_abun_per_sample3 <- annotation_uniref %>% filter (category == "UniRef90_characterization") %>% select (familyID, feature) %>% rename (feature2 = feature) %>% filter (feature2 %in% c ("UniRef90_unknown", "UniRef90_uncharacterized")) %>% right_join(homology_abun_per_sample) %>% mutate ( feature2 = replace_na(feature2, "UniRef90_characterized")) %>%  mutate (homology = case_when(
  feature2 == "UniRef90_uncharacterized" & feature == "strong_homology" ~ "SU", 
  feature2 == "UniRef90_characterized" & feature == "strong_homology" ~ "SC", 
  feature2 == "UniRef90_unknown" & feature == "weak_homology" ~ "RH", 
  feature2 == "UniRef90_unknown" & feature == "worse_homology" ~ "NH"
)) %>% select (- c(feature2, feature)) %>% relocate (homology, .after = 1)


#homology_abun_per_sample2 <- homology_abun_per_sample %>% group_by(feature) %>% summarize_at(vars(-1), sum, na.rm = TRUE)  %>% pivot_longer(, cols = -feature, names_to = "sample", values_to = "abundance")

homology_abun_per_sample2 <- homology_abun_per_sample3 %>% group_by(homology) %>% summarize_at( vars(-1), sum, na.rm = TRUE)  %>% pivot_longer(, cols = -homology, names_to = "Sample", values_to = "abundance") %>% left_join((drup_metadata %>% select (c (Sample, Response))))



# Stacked + percent
ggplot(homology_abun_per_sample2, aes(fill=homology, y=abundance, x=Sample)) + 
    geom_bar(position="fill", stat="identity", width = 1) + 
  theme(axis.text.x  = element_blank()) + 
  labs (y = "Abundance(%)", fill = "Homology") +
  theme(text = element_text(size=14))
ggsave ("abun_percent_homology_sample.png", path = path_plots)



homology_abun_per_sample2 %>% filter (Response %in% c("Responder", "Non-responder")) %>% ggplot( aes(fill=homology, y=abundance, x=Sample, decreasing = TRUE)) + 
    geom_bar(position="fill", stat="identity", width = 1) + 
  theme(axis.text.x  = element_blank()) + 
  labs (y = "Abundance(%)", fill = "Homology") + 
  facet_grid( cols = vars(Response), scales="free_x") +
  theme(text = element_text(size=16))

ggsave ("abun_percent_homology_sample_facet.response.png", path = path_plots)





cluster_mean_abun <- homology_abun_per_sample3 %>% select (contains ("DRUP")) %>% rowMeans()
homology_abun_per_sample3 <- homology_abun_per_sample3 %>% mutate (mean_abun = cluster_mean_abun)

## Distribution of mean abundance of protein families. 
ggplot (homology_abun_per_sample3, aes (x = log(mean_abun), fill = homology)) + geom_density (alpha=.3) + theme(text = element_text(size=16)) + theme_classic2()

ggsave ("mean_abundance_homology.png", path = path_plots, height = 4, width = 6 )


## Distribution of mean abundance of protein families (boxplots) 
ggplot (homology_abun_per_sample3, aes (y = log(mean_abun), fill = homology, x = homology)) +
  geom_boxplot( outlier.alpha = 0.1) +
  ylab("log (mean abundance)") +
  theme_bw() + 
  theme (
    text = element_text(size = 16), 
    panel.border = element_blank(), 
    panel.grid = element_blank(), 
    axis.line = element_line(color = "black")
  )

ggsave ("mean_abundance_homology_boxplots.png", path = path_plots)

## Distribution of mean abundance of protein families (boxplots with pvalues)
my_comparisons = list (c("NH", "SC"), c("NH", "SU"), c("RH", "SC"), c ("RH", "SU"))
ggplot (homology_abun_per_sample3, aes (y = log(mean_abun), fill = homology, x = homology)) +
  geom_boxplot( outlier.alpha = 0.1) +
  stat_compare_means(comparisons = my_comparisons, label = "p.signif" ) +
  ylab("log (mean abundance)") +
  theme_bw() + 
  theme (
    text = element_text(size = 16), 
    panel.border = element_blank(), 
    panel.grid = element_blank(), 
    axis.line = element_line(color = "black")
  )


ggsave ("mean_abundance_homology_boxplots_pval.png", path = path_plots)

```
The relative abundance of protein families depending on their homology classification is very similar between samples (there is no distinctiction between responders and non responders)

The distribution of protein families abundance given their homology classification shows that the protein families with strong homology (SC, SU) tend to have a higher abundance than the protein families with relative homology (RH) and no-homology (NH)


Drop samples that should not be present in homology_per_sample3 dataframe
```{r}
homology_abun_per_sample3 <- homology_abun_per_sample3 %>% select (-setdiff( (homology_abun_per_sample3 %>% select (contains ("DRUP")) %>% colnames()), final_metadata$Sample))


#Add a column of prevalence 
homology_abun_per_sample3$prevalence <- rowSums (homology_abun_per_sample3 %>% select (contains("DRUP")) >0 ) / dim(final_metadata)[1]

homology_abun_per_sample3 <- homology_abun_per_sample3 %>% filter (prevalence != 0)


```



```{r}
#Number of proteins families per each 
ggplot (homology_abun_per_sample3, aes (homology)) + geom_bar( aes(fill = homology)) + 
  theme(text = element_text(size=16))

### Plot the proportions as well. 
ggsave ("count_homology.png", path = path_plots)


#Proportions or each cluster by homology
homology_abun_per_sample3 %>% group_by(homology) %>% summarise (per = round (100*n()/n_clusters, 2), n = n())



```


```{r}

## Number of proteins forming the cluster depending on the homology...
cluster_size <- annotation_attribute %>% filter (key == "cluster_size") 

#Add to the data frame
homology_abun_per_sample3 <- homology_abun_per_sample %>% left_join(.,(cluster_size %>% rename (n_proteins = value) %>% select (familyID, n_proteins) ))

homology_abun_per_sample3 %>% group_by(homology) %>% summarise (mean = mean (cluster_size), max = max(cluster_size))

```
The mean number of proteins forming the clusters is similar among the different groups of clusters, Though NH clusters tend to be smaller, (less clusters bigger than 1). 




*Mean prevalence*
```{r}
# # Add prevalence to homology_abun_per_sample3
# homology_abun_per_sample3 <- homology_abun_per_sample3 %>% left_join(., (annotation %>% filter( feature == "DNA_prevalence") %>% select (familyID, annotation) %>% rename (prevalence = annotation))) 

#Add a column of prevalence 
homology_abun_per_sample3$prevalence <- rowSums (homology_abun_per_sample3 %>% select (contains("DRUP")) >0 ) / dim(final_metadata)[1]


#prevalence plot (against abundance...)
homology_abun_per_sample3 %>%
  ggplot (aes (x = as.numeric(prevalence), y = log(mean_abun))) +
  geom_jitter(alpha = 0.25) +
  geom_smooth(method = "lm")+ 
  stat_cor() +
  geom_density_2d()+
  theme_bw() + 
  ylab ("log mean abundance (cpm)") +
  xlab ("Prevalence") + 
  theme(
    text = element_text(size=14), 
    panel.grid = element_blank(), 
    panel.border = element_rect (color = "black")
    )

ggsave(file = "log_abun~prevalence_2.png", path = path_plots)



homology_abun_per_sample3 %>%
  ggplot (aes (x = as.numeric(length), y = log(mean_abun))) +
  geom_jitter(alpha = 0.25) +
  geom_smooth(method = "lm")+ 
  stat_cor() +
  #geom_density_2d()+
  theme_bw() + 
  ylab ("log mean abundance (cpm)") +
  xlab ("Prevalence") + 
  theme(
    text = element_text(size=14), 
    panel.grid = element_blank(), 
    panel.border = element_rect (color = "black")
    )


## Remake
homology_abun_per_sample3 %>%  drop_na() %>% mutate (prevalence = jitter (as.double(prevalence), factor = 2)) %>%  ggplot (aes (x = prevalence, y = log(mean_abun)), position = "jitter") + geom_hex(binwidth = c(0.01, 0.16), aes(fill = stat(count))) + facet_grid(rows = vars(homology)) + theme(text = element_text(size=14))
ggsave(file="log.abun_prevalence_facet.homology.png", path = path_plots, width=6, height=8, dpi=300)

#Density of prevalence
homology_abun_per_sample3 %>% mutate (prevalence = jitter (as.double(prevalence), factor = 1)) %>% ggplot (aes (x = prevalence, fill = homology)) + geom_density (alpha=.3) + theme(text = element_text(size=16)) + theme_classic2()


ggsave(file="density_prevalence.png", path = path_plots, height = 4, width = 6)


#Make prevalence one depending on responden or non responders....

```



There is a correlation between the prevalence and the abundance of the protein families. 

```{r}
# Prevalence abundance difference per sample. 
homology_abun_per_sample3 %>% drop_na() %>% select (c("familyID", "homology", "prevalence")) %>%
  mutate (prevalence = as.double (prevalence)) %>% 
  ggplot (aes (x = homology, y = prevalence, fill = homology)) + geom_boxplot( outlier.alpha = 0.1)  + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) )

ggsave ("pravalence_homology.png", path = path_plots)

my_comparisons = list (c("NH", "SC"), c("NH", "SU"), c("RH", "SC"), c ("RH", "SU"))

homology_abun_per_sample3 %>% drop_na() %>% select (c("familyID", "homology", "prevalence")) %>%
  mutate (prevalence = as.double (prevalence)) %>% 
  ggplot (aes (x = homology, y = prevalence, fill = homology)) + geom_boxplot( outlier.alpha = 0.1)   + theme (text = element_text(size = 16)) + stat_compare_means(comparisons = my_comparisons, label = "p.signif" ) + ## Add statistical comparissons with ggpubr package.  
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) )

ggsave ("pravalence_homology_pval.png", path = path_plots)

```






```{r}
# There is a small percentage of proteins that don't have abunance available...
homology_abun_per_sample3 %>% filter (is.na(DRUP01010212T1)) %>% dim(.) %>% .[1] / n_clusters * 100
```
1.31 % of the predicted protein families don't have abundance information (thus, are removed from the analysis). 


```{r}

homology_abun_per_sample3 <- homology_abun_per_sample3 %>%  filter (prevalence != NaN)
n_clusters2 <- n_clusters - as.double(homology_abun_per_sample3$prevalence) %>% is.na() %>% sum() #265101
```
Number of protein clusters after eliminating the ones that don't have information of the abundance and the prevalence = 2625101 




distribution of protein lengths between the groups of protein families. 
```{r}
cluster_length <- annotation_attribute %>% filter (key == "rep_length") %>% select ( c("familyID", "value")) %>% rename (length = value) %>% mutate (length = as.numeric(length))

homology_abun_per_sample3 <- homology_abun_per_sample3 %>% left_join(cluster_length)

homology_abun_per_sample3 %>% ggplot (aes (x = log(length), fill = homology, y = stat(count))) + geom_density(alpha=.3) + 
 theme_bw() + theme (text = element_text(size = 16), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) 


ggsave ("protein_lenght_distribution.png", path = path_plots)


homology_abun_per_sample3 %>% ggplot (aes (x = homology, y = log(length), fill = homology)) +  geom_boxplot( outlier.alpha = 0.1)   + theme (text = element_text(size = 16)) + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16))

ggsave ("protein_lenght_distribution_boxplot.png", path = path_plots)


my_comparisons = list (c("NH", "SC"), c("NH", "SU"), c("RH", "SC"), c ("SC", "SU"))
homology_abun_per_sample3 %>% ggplot (aes (x = homology, y = log(length), fill = homology)) +  geom_boxplot( outlier.alpha = 0.1)   + theme (text = element_text(size = 16)) + stat_compare_means(comparisons = my_comparisons, label = "p.signif" ) + ## Add statistical comparissons with ggpubr package.  
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) )

ggsave ("protein_lenght_distribution_boxplot_pval.png", path = path_plots)



```

It can be observed that the NH clusters have a smaller length compared with the other groups of proteins. 
All the comparisons are significative (high sample size)


###Number of clusters per sample
```{r}

#Number of clusters per sample and per homology
homology_abun_per_sample3_long <- homology_abun_per_sample3 %>% pivot_longer(cols = contains ("DRUP"), names_to = "sampleId", values_to = "cpm")


n_clusters_per_sample_per_homology <- homology_abun_per_sample3_long %>% filter (cpm > 0 ) %>% group_by(sampleId, homology) %>% summarise(n = n ())

n_clusters_per_sample_per_homology %>% 
  ggplot (aes (x = reorder (sampleId, n, decreasing = TRUE), y = n, fill = homology)) + 
  geom_bar ( stat = "identity", width = 1) +
  theme(axis.text.x  = element_blank(), text = element_text(size = 14)) +
  labs (y = "# of protein clusters", fill = "Homology", x = "Sample")
ggsave ("numb_clusters_homology_sample.png", path = path_plots)


n_clusters_per_sample_per_homology <- n_clusters_per_sample_per_homology %>% inner_join(., (final_metadata %>% select (Sample, Response, timepoint) %>% rename (sampleId = Sample)))


#Number of clusters per homology, per sample (grouped by response)
n_clusters_per_sample_per_homology %>% 
ggplot (aes (x = reorder (sampleId, n, decreasing = TRUE), y = n, fill = homology)) + 
  geom_bar ( stat = "identity", width = 1) +
  facet_wrap( ~ Response, scales = "free_x") +
  theme(axis.text.x  = element_blank(), text = element_text(size = 14)) + 
  labs (y = "# of protein clusters", fill = "Homology", x = "Sample")
ggsave ("numb_clusters_homology_sample_response.png", path = path_plots)



head (n_clusters_per_sample_per_homology)

n_clusters_per_sample_per_homology %>% 
  ggplot (aes (x = homology, y = n, fill = homology)) +
  #geom_violin() + 
  geom_boxplot() +
  geom_jitter (alpha = 0.2) +
  labs (y = "# of protein clusters") + 
  facet_grid (timepoint ~ Response) + 
  theme_bw() * 
  theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text (size = 16))

ggsave ("numb_clusters_homology_response_time.png", path = path_plots)



#remove the long df: takes 30 gb of space. 
rm (homology_abun_per_sample3_long)
```
The proportion of clusters by homology is mantained among samples. However the number of clusters detected per sample vary greatly. There are ones on which is extraordinarily low. 



Number of protein clusters found in each sample: 
```{r}
n_clusters_per_sample <- n_clusters_per_sample_per_homology %>% group_by (sampleId) %>% summarise (sum = sum(n)) %>% rename (Sample = sampleId) %>% left_join (., (drup_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use")))) %>% rename (n_clusters = sum)


#Per batch
n_clusters_per_sample %>% ggplot (aes (x = Batch, y = n_clusters, fill = Batch)) + geom_violin() + geom_boxplot(width = 0.2) + geom_jitter (alpha = 0.2) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) ) + stat_compare_means( comparisons = list(c("BatchA", "BatchB")), label = "p.signif" )
ggsave ("num_clusters_sample_batch.png", path = path_plots)
  

#Per ATB use
n_clusters_per_sample %>% ggplot (aes (x = ATB_use, y = n_clusters, fill = ATB_use)) + geom_violin() + geom_boxplot(width = 0.2) + geom_jitter (alpha = 0.2)+  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) ) + stat_compare_means (comparisons = list( c( "No", "Unknown"), c ("No", "Yes"), c("Unknown", "Yes")), label = "p.signif")
ggsave ("num_clusters_sample_atb.png", path = path_plots)

#Per time point
n_clusters_per_sample %>% ggplot (aes (x = timepoint, y = n_clusters, fill = timepoint)) + geom_violin() + geom_boxplot(width = 0.2) + geom_jitter (alpha = 0.2)+ 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) ) + stat_compare_means (comparisons = list( c( "T1", "T2"), c ("T1", "T3"), c("T2", "T3")), label = "p.signif")
ggsave ("num_clusters_sample_timepoint.png", path = path_plots)


#Per response
n_clusters_per_sample %>% filter (!Response %in% c("MISSING", "NE")) %>%  ggplot (aes (x = Response, y = n_clusters, fill = Response)) + geom_violin() + geom_boxplot(width = 0.2) + geom_jitter (alpha = 0.2)+  labs (y = "# of clusters", x = "Response") + 
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), text = element_text(size = 16) ) + stat_compare_means (comparisons = list( c( "Non-responder", "Responder")), label = "p.signif")
ggsave ("num_clusters_sample_response.png", path = path_plots)

```
These variables don't explain why some samples have a significant reduction in the number of sam



```{r}
annotation_uniref %>% filter (category == "UniRef90_characterization") %>%
  #filter (!c("UniRef90_uncharacterize", "UniRef90_unknown")) %>% 
  group_by(feature) %>% summarise (n = n(), per = round (100*n()/n_clusters, 2))
  #filter (feature == "UniRef90_PfamDomain") %>% 
  #distinct(familyID) %>% nrow()
  
```
More protein families with UniRef90_PfamDomain than StrongHomology...




###Functial annotation exploration

```{r}
annotation %>% distinct(method) %>% pull()
```





*TMHMM/Phobius*. Transmembrane regions. 
```{r}
annotation %>% filter (method == "TMHMM/Phobius") %>% group_by(feature) %>% summarise (n =n(), percentage = round (100 * n() / n_clusters, digits = 3))
```



*Phobius* and *SignalP* are tools that identify signaling peptides in protein sequences. 
SignalP uses deep neural networks, while Phobius is based in HMM. 
```{r}
#SignalP and Phobius identigy the signaling peptides. 
annotation %>% filter (method == "SignalP/Phobius") %>% group_by(feature) %>% summarise (n =n(), percentage = round (100 * n() / n_clusters, digits = 3))
##8.37% of the proteins clusters are predicted to have a signaling domain. 

```




*Domine* is a database of known and predicted protein domain (domain-domain) interactions. It contains interactions inferred from PDB entries, and those that are predicted by 13 different computational approaches using Pfam domain definitions.
There is also information about the specific hits (DDI) with human proteins
```{r}

#DOMINE
annotation %>% filter (method == "DOMINE") %>% group_by(feature) %>% summarise (n =n(), percentage = round (100 * n() / n_clusters, digits = 3))
```
Few proteins have this annotation... (0.4%). 


*ExpAtlas* or Expression Atlas database provides information about gene expression levels from RNA-seq studies and Microarrays studies. 
```{r}
#ExpAtlas
annotation %>% filter (method == "ExpAtlas") %>% group_by(feature) %>% summarise (n =n(), percentage = round (100 * n() / n_clusters, digits = 3))
```
The same protein families that have a Domine annotation also have a expression atlas annotation. 

*SIFTS* 
```{r}
#SIFTS
annotation %>% filter (method == "SIFTS") %>% group_by (feature) %>% summarise (n = n(), percentage = round (100 * n() / n_clusters, 3))
```
Again the same 10560 proteins... with this annotation. 



*InterProScan* InterProScan combines multiple analysis: 
```{r}
annotation %>% filter (method == "InterProScan") %>% group_by(feature) %>% summarise (n =n(), percentage = round (100 * n() / n_clusters, digits = 3))
```


*PfamDomain* Database of protein families that include annotations. 

```{r}
annotation %>% filter (feature == "InterProScan_PfamDomain") %>% group_by(annotation) %>% summarise (n = n())
```
PF00004 --> ATPasa familiy 
PF09847 --> Membrane protein of 12 TMs    



*Pfam2GO* 
```{r}
annotation %>% filter (method == "Pfam2GO") %>% group_by(annotation) %>% summarise (n = n())
```
GO:0005524 --> ATP binding domain. 



*Panther* (Protein Analysis Through Evolutionary relationships).
```{r}
annotation %>% filter (feature == "InterProScan_PANTHER") %>% group_by(annotation) %>% summarise (n = n())
```
PTHR23076 --> METALLOPROTEASE M41 FTSH (PTHR23076)
--- No panther annotation here...


*CDD* (Conserved Domain Database) is a protein annotation resource that consists of a collection of well-annotated multiple sequence alignment models for ancient domains and full-length protein
```{r}
annotation %>% filter (feature == "InterProScan_CDD") %>% group_by(annotation) %>% summarise (n =n())
```
cd00009 --> ATP binding site
cd00958 --> Active site involved in Schiff base formation; forms covalent linkage with the product
cd04242 --> Nucleotide binding site 

*Coils* Prediction of coiled coil regions in proteins.
```{r}
annotation %>% filter (feature == "InterProScan_Coils") %>% group_by(annotation) %>% summarise (n =n(), p = round (n()/n_clusters * 100, 3))

```


*MobiDBLite*. Tool for the prediciton of intrinsically disordered proteins. 
```{r}
annotation %>% filter (feature == "InterProScan_MobiDBLite") 
```


*Gene 3D* Structural assignment for whole genes and genomes using the CATH domain structure database. 
```{r}
annotation %>% filter (feature == "InterProScan_Gene3D") %>% group_by(annotation) %>% summarise (n = n())

```


Addition of prevalence and proteins names to each cluster in homology_abun_per_sample3 df
```{r}

# Add prevalence per group (response and non response) to each protein cluster
homology_abun_per_sample3 <- left_join (homology_abun_per_sample3, (annotation %>% filter (feature %in% c( "DNA-Non-responder_prevalence", "DNA-Responder_prevalence")) %>% 
  group_by (familyID) %>%
  distinct (feature, .keep_all = TRUE) %>% ungroup() %>% select (-c(category,method,AID)) %>% #Delete the repeated empty line.
  pivot_wider (names_from = feature, values_from = annotation)))

# Add protein names to each protein cluster
homology_abun_per_sample3 <- left_join( homology_abun_per_sample3 , (annotation_attribute %>% filter (category == "UniRef90_homology" & key == "Protein_names") %>% select (familyID, value) %>% rename (protein_name = value)))
```


##Assembly quality assesment: 

```{r}
quast_report <- read_tsv("~/fun_profiling/quast_assembly/quast_megahit_assembly/transposed_report.tsv")


#N50 plot: 
quast_report %>% ggplot (aes (y = N50)) +
  geom_boxplot() + 
  theme_bw() + 
  theme (
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank(), 
    panel.border = element_blank(), 
    axis.line = element_line(color = "black"),
    text = element_text(size = 16),
    axis.text.x = element_blank()
  )

#GC content plot: 
quast_report %>% ggplot (aes (y = `GC (%)`)) +
  geom_boxplot() + 
  theme_bw() + 
  theme (
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank(), 
    panel.border = element_blank(), 
    axis.line = element_line(color = "black"),
    text = element_text(size = 16),
    axis.text.x = element_blank()
  )

#Total length: 
quast_report %>% ggplot (aes (y = `Total length`)) +
  geom_boxplot() + 
  theme_bw() + 
  ylab ("Total length assemblies (pb)")+
  theme (
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank(), 
    panel.border = element_blank(), 
    axis.line = element_line(color = "black"),
    text = element_text(size = 16),
    axis.text.x = element_blank()
  )


quast_report <- quast_report %>% select (Assembly, `Total length`, N50, `GC (%)`) %>% rename (sampleId = Assembly) %>% mutate (sampleId = str_replace(sampleId, pattern = ".contigs", replacement = "")) %>% inner_join(., (n_clusters_per_sample_per_homology %>% group_by (sampleId) %>% summarize (n_clusters = sum(n)))) %>% left_join(., (final_metadata %>% select (Sample, Response, ATB_use, timepoint) %>% rename (sampleId = Sample)))
  
quast_report

quast_report %>% 
  ggplot (aes (x = `Total length`/10e6, y = n_clusters)) +
  geom_point(size = 2, aes (color = Response, shape = timepoint)) + 
  geom_smooth(method = "lm", size = 0.5) +
  stat_cor(label.x = 0, label.y = 9e5) +
  theme_bw() +
  xlab("Assembly size (Mbp)") + 
  ylab("# protein families") +
  theme (
    panel.border = element_rect(color = "black"), 
    #panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    #axis.line = element_line(color = "black"), 
    text = element_text(size = 16)
  ) 

ggsave("correlation_nfamilies_assemblysize.png", path = path_plots) 


```




plot the assembly length agains the total length of the sort read sequences. 


Addition of KEGG and GO and PFAM annotation to homology_abundance3 dataframe. 

```{r}
## add UniRef90 annotation to the df
homology_abun_per_sample3 <- annotation_uniref %>% filter (feature %in% c("strong_homology", "weak_homology")) %>% select (familyID, annotation) %>% rename(uniref_id = annotation) %>% left_join(homology_abun_per_sample3, .) 


homology_abun_per_sample3 <- annotation_uniref %>% filter (category == "UniRef90_characterization") %>% filter (feature == "UniRef90_PfamDomain") %>% select (familyID, annotation) %>% rename (PfamDomain = annotation) %>% left_join(homology_abun_per_sample3, .)

homology_abun_per_sample3 <- annotation_uniref %>% filter (category == "UniRef90_characterization") %>% filter (feature == "UniRef90_eggNOG") %>% select (familyID, annotation) %>% rename (eggNOG = annotation) %>% left_join(homology_abun_per_sample3, .)

homology_abun_per_sample3 <-annotation_uniref %>% filter (category == "UniRef90_characterization") %>% filter (feature == "UniRef90_KEGG-KOs") %>% select (familyID, annotation) %>% rename (KEGG_KOs = annotation) %>% left_join(homology_abun_per_sample3, .)
```


##Comparisson with Humman3: 

Loading of the Humman3 data
```{r}
#Loading of the unireff dataframe: 
humman_uniref <- read_tsv("/DATA/share/tom_masters/miguel/stratification/gene_families_unstratified.txt")

metawibele_samples <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/metawibele_proteinfamilies_nrm.tsv",n_max = 2)

## All the samples analyzed by metawibele (including the samples that were dropped later) 
metawibele_samples <- metawibele_samples %>% select (contains("DRUP")) %>% colnames()


#Reduce the uniref dataframe only to the samples that were analyzed with metawibele: 
humman_uniref <- humman_uniref %>% rename_with(.cols = contains ("DRUP"), .fn = function(x){str_replace(x, pattern = "_Abundance-RPKs", replacement = "")})
humman_uniref <- humman_uniref %>% select (`# Gene Family`, metawibele_samples)

humman_uniref$mean_abundance <- humman_uniref %>% select (contains ("DRUP")) %>% rowMeans()
humman_uniref <- humman_uniref %>% filter (mean_abundance > 0) ## remove also the proteins ID that were only present on the removed samples

##Comparisson of the differences number of uniref annotations: 

uniref_metawibele <- annotation_uniref %>% filter (feature %in% c("strong_homology", "weak_homology") ) %>% pull(annotation)
uniref_humman <- humman_uniref[-1,] %>% pull (`# Gene Family`)


# library
library(VennDiagram)
 
#Make the venndiagram
venn.diagram(
  x = list(
    uniref_metawibele,
    uniref_humman
    ),
  category.names = c("MetaWIBELE", "HUMAnN3"),
  filename = "VennDiagram.png", 
          lwd = 1,
          col=c("#440154ff", '#21908dff'),
          fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3)),
          cex = 1.3,
          fontfamily = "sans",
          print.mode=c("raw","percent"),
          cat.cex = 1.5,
          cat.default.pos = "outer",
          cat.pos = c(0, 0),
          cat.dist = c(0.055, 0.055),
          cat.fontfamily = "sans",
          cat.col = c("#440154ff", '#21908dff'),
          #rotation = 1
  
)

#Make the venndiagram using only the annotations of strong homology in metawibele
uniref_metawibele_sh <- annotation_uniref %>% filter (feature == "strong_homology" ) %>% pull(annotation)

venn.diagram(
  x = list(
    uniref_metawibele_sh,
    uniref_humman
    ),
  category.names = c("MetaWIBELE", "HUMAnN3"),
  filename = "VennDiagram_sh.png", 
          lwd = 1,
          col=c("#440154ff", '#21908dff'),
          fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3)),
          cex = 1.3,
          fontfamily = "sans",
          print.mode=c("raw","percent"),
          cat.cex = 1.5,
          cat.default.pos = "outer",
          cat.pos = c(360, 360),
          cat.dist = c(0.055, 0.055),
          cat.fontfamily = "sans",
          cat.col = c("#440154ff", '#21908dff'),
          #rotation = 1
  
)


### Make linear regression of the proteins that they have in common: 

uniref_common <- intersect (uniref_humman, uniref_metawibele)




## add annotaiton of the uniref_id t
homology_abun_per_sample3 <- annotation_uniref %>% filter (feature %in% c("strong_homology", "weak_homology")) %>% select (familyID, annotation) %>% rename(uniref_id = annotation) %>% left_join(homology_abun_per_sample3, .) 

## Make the metawibele dataframe with all the samples analyzed in metawibele + the unireff annotation to the correspondent samples
metawibele_uniref <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/metawibele_proteinfamilies_nrm.tsv")
metawibele_uniref$mean_abun <- metawibele_uniref %>% select (contains ("DRUP")) %>% rowMeans() 


metawibele_uniref <- metawibele_uniref %>% 
  rename (familyID = ID) %>% 
  select (familyID, mean_abun) %>%
  left_join(.,
            (annotation_uniref %>%
                 filter (
                   feature %in% c("strong_homology", "weak_homology")
                   ) %>% 
                 select(familyID, annotation) %>% 
                 rename (uniref_id = annotation)
             )
  )
humman_uniref <- humman_uniref %>% rename(uniref_id = `# Gene Family`) %>% select (uniref_id, mean_abundance) %>% .[-1,]
#Filter the 0s (Samples that have been removed). 
humman_uniref <- humman_uniref %>% filter (mean_abundance > 0) 


humman_uniref %>% filter (uniref_id %in% uniref_common) %>% rename (mean_abundance_humman = mean_abundance ) %>% left_join(., metawibele_uniref) %>% 
  filter (mean_abundance_humman > 0) %>% 
  ggplot (aes(x = log10(mean_abundance_humman), y = log10(mean_abun))) + 
  geom_jitter(alpha = 0.2) +
  #geom_point(size = 0.2) + 
  geom_smooth(method = "lm") + 
  xlab ("log10 HUMAnN 3 mean abundance") + 
  ylab ("log10 METAWIBELE mean abundance") +
  stat_cor() +
  theme_bw() + 
  theme(
    panel.border = element_rect (color = "black"), 
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank(),
    text = element_text (size = 16)
  )

ggsave("coor_abundance_humman_metawibele.png", path = path_plots)


## Same linear regression between common proteins but only the proteins with SH in uniref (not including the ones with remote homology 
# that have low confidence)

metawibele_uniref <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/characterization/finalized/metawibele_proteinfamilies_nrm.tsv")
metawibele_uniref$mean_abun <- metawibele_uniref %>% select (contains ("DRUP")) %>% rowMeans() 
metawibele_uniref_sh <- metawibele_uniref %>% 
  rename (familyID = ID) %>% 
  select (familyID, mean_abun) %>%
  left_join(.,
            (annotation_uniref %>%
                 filter (
                   feature == "strong_homology") %>% 
                 select(familyID, annotation) %>% 
                 rename (uniref_id = annotation)
             )
  )
uniref_common <- intersect (uniref_humman, uniref_metawibele_sh)

humman_uniref %>% filter (uniref_id %in% uniref_common) %>% rename (mean_abundance_humman = mean_abundance ) %>% left_join(., metawibele_uniref_sh) %>% 
  filter (mean_abundance_humman > 0) %>% 
  ggplot (aes(x = log10(mean_abundance_humman), y = log10(mean_abun))) + 
  geom_jitter(alpha = 0.2) +
  #geom_point(size = 0.2) + 
  geom_smooth(method = "lm") + 
  xlab ("log10 HUMAnN 3 mean abundance") + 
  ylab ("log10 METAWIBELE mean abundance") +
  stat_cor() +
  theme_bw() + 
  theme(
    panel.border = element_rect (color = "black"), 
    panel.grid.minor = element_blank(), 
    panel.grid.major = element_blank(),
    text = element_text (size = 16)
  )

ggsave("coor_abundance_humman_metawibele_sh.png", path = path_plots)


# Comparisson of abundance between the uniref protein families that were only detected by metawibele or the ones that were detected by unireff and humman
metawibele_uniref_sh %>% mutate ("common" = ifelse(uniref_id %in% uniref_common, "Shared with HUMAnN 3", "Unique")) %>% 
  ggplot(aes(y = log(mean_abun), x = common)) + 
  geom_violin(color = "#440154ff", fill = adjustcolor( "#440154ff", alpha.f = 0.3)) +
  geom_boxplot(width = 0.3, color = "#440154ff", fill = adjustcolor( "#440154ff", alpha.f = 0.3)) + 
  stat_compare_means(comparisons = list (c("Unique", "Shared with HUMAnN 3")), label = "p.signif")+
  xlab("UniRef90 proteins detected")+
  ylab("log mean abundance (cpm)") +
  ggtitle ("MetaWIBELE") + 
  theme_bw() + 
  theme (
    panel.border = element_blank(),
    panel.grid = element_blank(),
    axis.line = element_line(colour = "black"), 
    text = element_text(size = 16), 
    plot.title = element_text(hjust = 0.5)
  ) 
  #stat_compare_means( comparisons = list (c("Common", "Unique")))

ggsave("abundance_comparisson_common_uniref_metawibele.png", path = path_plots)


# Comparisson of abundance between the uniref protein families that were only detected by metawibele or the ones that were detected by unireff and humman
humman_uniref %>% mutate ("common" = ifelse(uniref_id %in% uniref_common, "Shared with MetaWIBELE", "Unique")) %>% 
  ggplot(aes(y = log(mean_abundance), x = common)) + 
  geom_violin(color = "#21908dff", fill = adjustcolor( "#21908dff", alpha.f = 0.3)) +
  geom_boxplot(width = 0.3, color = "#21908dff", fill = adjustcolor( "#21908dff", alpha.f = 0.3)) + 
  stat_compare_means(comparisons = list (c("Unique", "Shared with MetaWIBELE")), label = "p.signif")+
  ggtitle ("HUMAnN3") +
  xlab("UniRef90 proteins detected")+
  ylab("log mean abundance (RPKM)") +
  theme_bw() + 
  theme (
    panel.border = element_blank(),
    panel.grid = element_blank(),
    axis.line = element_line(colour = "black"), 
    text = element_text(size = 16), 
    plot.title = element_text(hjust = 0.5)
  ) 
  #stat_compare_means (comparisos = list (c("Common", "Unique")))
  
ggsave("abundance_comparisson_common_uniref_humann.png", path = path_plots)




```



Check if there are differences in the annotations of the proteins that are only detected by metawibele compared with the ones of humman.  
```{r}


uniref_common <- intersect (uniref_humman, uniref_metawibele_sh)


uniref_unique_metawibele <- setdiff(uniref_metawibele_sh, uniref_common)


length (uniref_common)
length (uniref_unique_metawibele)
length (uniref_metawibele_sh)
n_distinct(uniref_metawibele_sh)


#comparison between the unique proteis of unireff and the ones shared with humman

unique_percent <- homology_abun_per_sample3 %>% filter (uniref_id %in% uniref_unique_metawibele) %>% filter (homology %in% c ("SC", "SU")) %>% group_by (homology) %>% summarise (n = n()/dim(.)[1]) %>% mutate (proteins = c("Unique MetaWIBELE", "Unique MetaWIBELE"))


shared_percent <- homology_abun_per_sample3 %>% filter (uniref_id %in% uniref_common) %>% filter (homology %in% c ("SC", "SU")) %>% group_by (homology) %>% summarise (n = n()/dim(.)[1]) %>% mutate (proteins = c("Shared with HUMAnN", "Shared with HUMAnN"))


homology_abun_per_sample3 %>% filter (uniref_id %in% uniref_unique_metawibele) %>% filter (homology %in% c ("SC", "SU")) %>% select (KEGG_KOs) %>% n_distinct()

homology_abun_per_sample3 %>% filter (uniref_id %in% uniref_common) %>% filter (homology %in% c ("SC", "SU")) %>% select (KEGG_KOs) %>% n_distinct()


bind_rows(unique_percent, shared_percent) %>%
  ggplot (aes (x = proteins, y = n, fill = homology)) +
  geom_col() +
  xlab("") + 
  ylab("Percentage (%)")+
  theme_bw(base_size = 16)





```

The proteins that are annotated are the ones that are shared with humman3. In the ones that are uniquely detected by metawibele there are almost no SC proteins....







## Differential abundance analysis
```{r}

# Generate abundance and log Fold change table. 
abundance_df <- annotation_attribute %>% filter (category %in% c("MaAsLin2_DA", "UniRef90_homology"), key %in% c("qvalue", "log(FC)", "Protein_names")) %>% select (-TID) %>% select(-category)  %>% pivot_wider (names_from = key, values_from = value)
abundance_df <- abundance_df %>% rename( log_FC = `log(FC)`)  %>% mutate (qvalue = as.numeric(qvalue), log_FC = as.numeric(log_FC))

# Nas in qvalue and log(FC) are protein families are not present in one of the conditions. 
abundance_df <- abundance_df %>% drop_na (!Protein_names)

abundance_df <- abundance_df %>% left_join(., (homology_abun_per_sample3 %>% select (c("familyID", "DNA-Non-responder_prevalence", "DNA-Responder_prevalence"))))

#Filter by minimun of 20% prevalence in both groups. 
clusters_min_prevalence <- annotation %>% filter (feature %in% c( "DNA-Non-responder_prevalence", "DNA-Responder_prevalence")) %>% 
  group_by (familyID) %>%
  distinct (feature, .keep_all = TRUE) %>% ungroup() %>% select (-c(category,method,AID)) %>% #Delete the repeated empty line.
  pivot_wider (names_from = feature, values_from = annotation) %>%
  filter(`DNA-Non-responder_prevalence` > 0.2 | `DNA-Responder_prevalence` > 0.2) #Threshold of prevalence

#Protein clusters that pass the prevalence threshold and have a significative pvalue after multiple hyphotesis testing correction. 
abundance_df %>% 
  filter (familyID %in% (clusters_min_prevalence %>% pull(familyID))) %>% filter (qvalue <= 0.05) %>% arrange (qvalue)

abundance_df %>% filter(qvalue <= 0.05) %>% arrange (qvalue)

```
Only two protein clusters are signinficative associated....




###Volcano maaslin
Volcano plot of the Maaslin DA. 
```{r}
#Volcano plot XD
p1 <- abundance_df %>% 
  #filter (familyID %in% (clusters_min_prevalence %>% pull(familyID))) %>%
  add_column(color = ifelse (.$qvalue <= 0.05, "S", "NS")) %>% 
  drop_na (!Protein_names) %>% 
  ggplot(aes ( log_FC, -log(qvalue,10), color = color)) + # -log10 conversion  
  geom_point(size = 2/5) +
  xlab(expression("log"[2]*"FC")) + 
  ylab(expression("-log"[10]*"FDR")) +
  theme(text = element_text(size=14)) +
  scale_color_manual (values = c("S" = "Red", "NS" = "Black"))
p1
```

Volcano plot of proteins families with a prevalence > 0.2 in at least one group. 

The volcano plot is not very convincing (maybe be because is a linear mixed model?) 



```{r}
#Volcano plot
p3 <- abundance_df %>% 
  filter (familyID %in% (clusters_min_prevalence %>% pull(familyID))) %>%
  drop_na (!Protein_names) %>% 
  ggplot(aes ( log_FC, -log(qvalue,10))) + # -log10 conversion  
  geom_point(size = 2/5, show.legend = FALSE) +
  xlab(expression("log"[2]*"FC")) + 
  ylab(expression("-log"[10]*"FDR")) +
  theme(text = element_text(size=14)) +
  geom_point( data = . %>% filter (qvalue <= 0.05), aes (color = "Red"), show.legend = FALSE)+
  geom_text_repel(data = . %>% filter (qvalue <= 0.05), 
                  aes (label = Protein_names, color = "Red"), show.legend = FALSE, size = 3.5, box.padding = 1.2) +
  coord_cartesian( xlim = c (-7,7), ylim = c(0, 2.5)) + theme_bw() +
  theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

p3
ggsave("volcanoplot_maaslin_freqfilter0.2.png", path = path_plots)
```




```{r}

abundance_prot_families %>% select (-familyID) %>% colSums() ## To many numbers to be added ?
# The total number of occurance of proteins is very similar between samples. Min=96e+05, Max=99e+05



# Number or proteins families per sample: 
nprot_families_per_sample <- abundance_prot_families %>% summarise_all(funs(sum(. > 0)))

# Selects only the samples that where filtered. (only responders and non-responders). 
nprot_families_per_sample2 <- nprot_families_per_sample %>% select (final_metadata $Sample) %>% t() %>% as_tibble(column_name = "Number_prot_clusters")
nprot_families_per_sample2 <- nprot_families_per_sample2 %>% add_column ( Sample =(nprot_families_per_sample %>% select (final_metadata $Sample) %>% colnames()), .before = 1) 

nprot_families_per_sample2 <- rename (nprot_families_per_sample2, N_prots = V1)
 
nprot_families_per_sample2 <- nprot_families_per_sample2 %>% left_join (., (final_metadata %>% select (c("Sample", "Response"))))

p <- ggplot(nprot_families_per_sample2, aes (x = Response, y = N_prots)) +
  geom_violin() +
  geom_jitter() +
  ylab("Number protein clusters") + 
  xlab ("") + 
  theme(text = element_text (size = 16))
  
p
ggsave("proteinclusternumber_response.png", path = path_plots)






```

###Rarefracion analysis:
```{r}
abundance_prot_families_mt <- abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata$Sample) %>% as.matrix() 

rarecurve <- rarecurve(round(t(abundance_prot_families_mt)), step = 10000, label = F, tidy = TRUE)

rarecurve <- rarecurve %>% rename (Sample_Size = Sample, Sample = Site) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId")))) 



## Rarecurve plot
rarecurve_plot <- rarecurve %>% ggplot(aes (x = Sample_Size, y = Species, color = Response)) + 
  geom_line(aes (group = Sample), alpha = 0.3) +
  # geom_smooth (aes (group = Response) , size = 2 , method = "loess")
  geom_smooth (data=rarecurve %>% filter (Sample_Size < 960002) %>% group_by(Response,Sample_Size) %>% summarise (mean = mean (Species), sd = sd(Species)),
               aes (x = Sample_Size, y = mean, color = Response, ymin = mean - sd, ymax = mean + sd), stat = "identity", se = FALSE)
rarecurve_plot

```


### PCoA

First applying directly the Bray curtis dissimilarity and plottiing the first two PCoA. 
```{r}
bray_distance <- vegdist (t(abundance_prot_families_mt))
pcoa <- pcoa(bray_distance)
```



```{r}

pcoa_plot <- pcoa$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), color = "blue") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), color = "red") +
  xlab (paste0("PCo1 (",round(pcoa$values[1,1], 2),"%)"))+
  ylab (paste0("PCo2 (",round(pcoa$values[2,1], 2),"%)")) +
  ggtitle ("PCoA protein clusters abundance")
pcoa_plot


##PCoA of BrayCurtis dissimilarity of T1 and T2
bray_distance_T1 <- vegdist (t(abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% filter (timepoint == "T1") %>% pull (Sample)) %>% as.matrix() ))
pcoa_T1 <- pcoa(bray_distance_T1)

bray_distance_T2 <- vegdist (t(abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% filter (timepoint == "T2") %>% pull (Sample)) %>% as.matrix() ))
pcoa_T2 <- pcoa(bray_distance_T2)



pcoa_plot_T1 <- pcoa_T1$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_T1$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PCo1 (",round(pcoa$values[1,3] * 100, 2),"%)"))+
  ylab (paste0("PCo2 (",round(pcoa$values[2,3] * 100, 2),"%)")) +
  ggtitle ("T1") +
  annotate("text", label = "test") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )

pcoa_plot_T2 <- pcoa_T2$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_T2$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PCo1 (",round(pcoa_T2$values[1,3]*100, 2),"%)"))+
  ylab (paste0("PCo2 (",round(pcoa_T2$values[2,3]*100, 2),"%)")) +
  ggtitle ("T2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )


## Adonis test to compare the significance of the clusters differences.
adonis2(bray_distance_T1 ~ Response, data = (final_metadata %>% filter (timepoint == "T1")))
adonis2(bray_distance_T2 ~ Response, data = (final_metadata %>% filter (timepoint == "T2")))



ggarrange(pcoa_plot_T1, pcoa_plot_T2, common.legend = TRUE, legend = "bottom")

ggsave("pcoa_T1_T2.png", path = path_plots, height = 4, width = 8)


pcoa_plot_T1
pcoa_plot_T2

```

PCoA using the CLR normalization of the data (aitchison dissimilarity)
```{r}
##PCoA of aitchison dissimilarity of T1 and T2
ait_distance_T1_clr <- vegdist (clr(t(abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% filter (timepoint == "T1") %>% pull (Sample)) %>% as.matrix() )), method = "euclidean")
pcoa_T1_clr <- pcoa(ait_distance_T1_clr)

ait_distance_T2_clr <- vegdist (clr(t(abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% filter (timepoint == "T2") %>% pull (Sample)) %>% as.matrix() )), method = "euclidean")
pcoa_T2_clr <- pcoa(ait_distance_T2_clr)


pcoa_plot_T1 <- pcoa_T1_clr$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_T1_clr$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PC1 (",round(pcoa_T1_clr$values[1,3] * 100, 2),"%)"))+
  ylab (paste0("PC2 (",round(pcoa_T1_clr$values[2,3] * 100, 2),"%)")) +
  ggtitle ("T1") +
  annotate("text", label = "test") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )

pcoa_plot_T2 <- pcoa_T2_clr$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_T2_clr$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PC1 (",round(pcoa_T2_clr$values[1,3]*100, 2),"%)"))+
  ylab (paste0("PC2 (",round(pcoa_T2_clr$values[2,3]*100, 2),"%)")) +
  ggtitle ("T2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )


## Adonis test to compare the significance of the clusters differences.
adonis2(bray_distance_T1_clr ~ Response, data = (final_metadata %>% filter (timepoint == "T1")))
adonis2(bray_distance_T2_clr ~ Response, data = (final_metadata %>% filter (timepoint == "T2")))



ggarrange(pcoa_plot_T1, pcoa_plot_T2, common.legend = TRUE, legend = "bottom")

ggsave("pca_aitchison_T1_T2.png", path = path_plots, height = 4, width = 8)

pcoa_plot_T1
pcoa_plot_T2



```

#### PCA aitchison distance all samples (feature selection by prevalence)

```{r}

##PCoA of aitchison dissimilarity of T1 and T2
ait_distance_clr <- vegdist (clr(t(abundance_prot_families %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% pull (Sample)) %>% as.matrix() )), method = "euclidean")
pcoa_clr <- pcoa(ait_distance_clr)

##PCoA of aitchison dissimilarity low prevalence proteins
ait_distance_lp_clr <- vegdist (clr(t(abundance_prot_families %>% filter (familyID %in% (homology_abun_per_sample3 %>% slice_min(prevalence, prop = 0.2) %>% select (familyID, prevalence) %>% pull(familyID))) %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% pull (Sample)) %>% as.matrix() )), method = "euclidean")
pcoa_lp_clr <- pcoa(ait_distance_lp_clr)

##PCoA of aitchison dissimilarity high prevalence proteins
ait_distance_hp_clr <- vegdist (clr(t(abundance_prot_families %>% filter (familyID %in% (homology_abun_per_sample3 %>% slice_max(prevalence, prop = 0.2) %>% select (familyID, prevalence) %>% pull(familyID))) %>% column_to_rownames(var = "familyID") %>%  select (final_metadata %>% pull (Sample)) %>% as.matrix() )), method = "euclidean")
pcoa_hp_clr <- pcoa(ait_distance_hp_clr)


```

```{r}




pcoa_plot_T1 <- pcoa_clr$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_clr$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PC1 (",round(pcoa_T1_clr$values[1,3] * 100, 2),"%)"))+
  ylab (paste0("PC2 (",round(pcoa_T1_clr$values[2,3] * 100, 2),"%)")) +
  ggtitle ("T1") +
  annotate("text", label = "test") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )



pcoa_plot_T2 <- pcoa_lp_clr$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_lp_clr$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PC1 (",round(pcoa_T2_clr$values[1,3]*100, 2),"%)"))+
  ylab (paste0("PC2 (",round(pcoa_T2_clr$values[2,3]*100, 2),"%)")) +
  ggtitle ("T2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )



pcoa_plot_T3 <- pcoa_hp_clr$vectors %>% as_tibble() %>% add_column(Sample = rownames(pcoa_hp_clr$vectors), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "ATB_use")))) %>% 
  ggplot(aes ( x = Axis.1, y = Axis.2)) + geom_point (aes (color = Response)) + 
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment (data = (. %>% filter (Response == "Responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  geom_segment (data = (. %>% filter (Response == "Non-responder")), aes (x = mean (Axis.1), y = mean (Axis.2), xend = Axis.1, yend = Axis.2, color  = Response), alpha = 0.8) +
  xlab (paste0("PC1 (",round(pcoa_T2_clr$values[1,3]*100, 2),"%)"))+
  ylab (paste0("PC2 (",round(pcoa_T2_clr$values[2,3]*100, 2),"%)")) +
  ggtitle ("T2") +
  theme_bw() +
  theme(
    panel.grid = element_blank(), 
    text = element_text (size = 16)
  )


pcoa_plot_T1
pcoa_plot_T2
pcoa_plot_T3



## Adonis test to compare the significance of the clusters differences.
adonis2(bray_distance_T1_clr ~ Response, data = (final_metadata %>% filter (timepoint == "T1")))
adonis2(bray_distance_T2_clr ~ Response, data = (final_metadata %>% filter (timepoint == "T2")))



ggarrange(pcoa_plot_T1, pcoa_plot_T2, common.legend = TRUE, legend = "bottom")

#ggsave("pca_aitchison_T1_T2.png", path = path_plots, height = 4, width = 8)


```




Applying Log Centered Ration normalization to the data. 

Make PCA of LCR transformation (similar to aitchisono distance)
```{r}
abundance_prot_families_mt_clr <- clr (t(abundance_prot_families_mt))
#euclidean <- vegdist (t(abundance_prot_families_mt_clr))

pca_abundance <- prcomp (abundance_prot_families_mt_clr)


#pca_plot <- autoplot (pca_abundance, data = abun_prot_fam_clr_df, color = "Response")



PCs_abundance <- pca_abundance$x %>% as_tibble() %>%  add_column(Sample = rownames(pca_abundance$x), .before = 1) %>% left_join (., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use", "tumor_group"))))  %>% mutate (, Id_num = as.numeric(factor (.$patientId)))

PCs_12_mean_sample <- PCs_abundance %>% group_by(patientId) %>% summarise (x = mean(PC1), y = mean (PC2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
PCs_abundance <- PCs_abundance %>% left_join (., PCs_12_mean_sample)


#Response
pca_plot1 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = Response)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("PCA protein clusters abundance") +
  theme(text = element_text(size=12))

#Timepoint
pca_plot2 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = timepoint)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("PCA protein clusters abundance") +
  theme(text = element_text(size=12))

#Batch
pca_plot3 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = Batch)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("PCA protein clusters abundance")+
  theme(text = element_text(size=12))

#Tumor_groups
pca_plot4 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = tumortype_group)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  theme(text = element_text(size=12))

#Patient ID
pca_plot5 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = PCs_12_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = PC1, yend = PC2, color = patientId), show.legend = FALSE, alpha = 0.4) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  theme(text = element_text(size=12))

#Antibiotics use
pca_plot6 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = ATB_use)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  theme(text = element_text(size=12))

#Clinical Benefit
pca_plot7 <- PCs_abundance %>% ggplot (aes (x = PC1, y = PC2)) + geom_point( aes (color = CB)) +
  xlab (paste0("PC1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  ylab (paste0("PC2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  theme(text = element_text(size=12))


pca_plot1
ggsave("pca_abundance_response.png", path = path_plots, height = 4, width = 6)
pca_plot2
ggsave("pca_abundance_timepoint.png", path = path_plots, height = 4, width = 6)
pca_plot3
ggsave("pca_abundance_batch.png", path = path_plots, height = 4, width = 6)
pca_plot4
ggsave("pca_abundance_tumortype.png", path = path_plots, height = 4, width = 6)
pca_plot5
ggsave("pca_abundance_patientid.png", path = path_plots, height = 4, width = 6)
pca_plot6
ggsave("pca_abundance_antibiotics.png", path = path_plots, height = 4, width = 6)
pca_plot7
ggsave("pca_abundance_cb.png", path = path_plots, height = 4, width = 6)


```


###Distance comparisson: 


bray curtis dissimilarity
```{r}
#Make the bray curtis dissimilarity a matrix
bray_distance_mt <- as.matrix (bray_distance)


#Data frame with the bray dissimilarity matrices...
bray_distance_df <- bray_distance_mt %>% as_tibble () %>% mutate (Sample = colnames(.), .before = 1) 


#Boxplot for the Bray Curtis distance between responders and non responders
bray_distance_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "BC_dissimilarity") %>% left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
  left_join(., (final_metadata %>% select (Sample, patientId) %>% rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
  filter (patientId == patientId2) %>% filter (Sample != Sample2) %>% filter (timepoint== "T1") %>% 
  ggplot (aes (x = Response, y = BC_dissimilarity)) + 
  geom_boxplot(aes (fill = Response), show.legend = FALSE) + 
  #geom_jitter(aes(color = ATB_use)) + 
  ylab ("Bray Curtis Dissimilarity T1-T2")+
  stat_compare_means(comparisons = list (c("Responder", "Non-responder")),label = "p.signif" )+
  theme_classic(base_size = 16)

ggsave("BrayCurtis_Responders_Nonresponders.png", path = path_plots, height = 4, width = 4)

  

#Check if there is more difference if we remove the samples that only detect very few protein clusters. 
bray_distance_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "BC_dissimilarity") %>%
  left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
  left_join(., (final_metadata %>% select (Sample, patientId) %>%
                  rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
  filter (patientId == patientId2) %>%
  left_join(., (quast_report %>%
                  rename (Sample = sampleId) %>%
                  select (Sample, n_clusters))) %>%
    left_join(., (quast_report %>%
                  rename (Sample2 = sampleId, n_clusters2 = n_clusters) %>%
                  select (Sample2, n_clusters2))) %>%
  filter (n_clusters > 75000 & n_clusters2 > 75000) %>%
  filter (Sample != Sample2) %>%
  filter (timepoint== "T1") %>% 
  ggplot (aes (x = Response, y = BC_dissimilarity)) + 
  geom_boxplot() + 
  geom_jitter(aes(color = ATB_use)) + 
  geom_text_repel(aes (label = Sample)) 



#Boxplot 
bray_distance_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "BC_dissimilarity") %>% left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
  left_join(., (final_metadata %>% select (Sample, patientId) %>% rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
  mutate (same_patient = ifelse (patientId == patientId2, "Same patient", "Random")) %>% filter (Sample != Sample2) %>% filter (timepoint== "T1") %>% 
  ggplot (aes (x = same_patient, y = BC_dissimilarity)) + 
    #geom_jitter(aes(color = ATB_use)) + 
  ylab ("Bray Curtis Dissimilarity T1-T2")+
  stat_compare_means(comparisons = list(c("Random", "Same patient")),label = "p.signif", size = 5  )+
  theme_classic(base_size = 16) + 
  xlab("")+
  geom_boxplot(aes (fill = same_patient), show.legend = FALSE)
  
ggsave("BrayCurtis_random_paired.png", path = path_plots, height = 4.1, width = 4)

```


Aitchison dissimilarity
```{r}
#Make the aitchison dissimilarity  matrix
aitchison_mt <- as.matrix ( vegdist (t(abundance_prot_families_mt), method = "aitchison", pseudocount = 1))


#Data frame with the bray dissimilarity matrices...
aitchison_df <- aitchison_mt %>% as_tibble () %>% mutate (Sample = colnames(.), .before = 1) 


#Boxplot for the Bray Curtis distance between responders and non responders
aitchison_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "Aitchison_distance") %>% left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
left_join(., (final_metadata %>% select (Sample, patientId) %>% rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
filter (patientId == patientId2) %>% filter (Sample != Sample2) %>% filter (timepoint== "T1") %>% 
ggplot (aes (x = Response, y = Aitchison_distance)) + 
geom_boxplot(aes (fill = Response), show.legend = FALSE) + 
#geom_jitter(aes(color = ATB_use)) + 
ylab ("Aitchison distance T1-T2")+
stat_compare_means(comparisons = list (c("Responder", "Non-responder")), label = "p.signif" )+
theme_classic(base_size = 16)

ggsave("Aitchison_Responders_Nonresponders.png", path = path_plots, height = 4, width = 4)



#Check if there is more difference if we remove the samples that only detect very few protein clusters. 
# aitchison_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "Aitchison_distance") %>%
#   left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
#   left_join(., (final_metadata %>% select (Sample, patientId) %>%
#                   rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
#   filter (patientId == patientId2) %>%
#   left_join(., (quast_report %>%
#                   rename (Sample = sampleId) %>%
#                   select (Sample, n_clusters))) %>%
#     left_join(., (quast_report %>%
#                   rename (Sample2 = sampleId, n_clusters2 = n_clusters) %>%
#                   select (Sample2, n_clusters2))) %>%
#   filter (n_clusters > 75000 & n_clusters2 > 75000) %>%
#   filter (Sample != Sample2) %>%
#   filter (timepoint== "T1") %>% 
#   ggplot (aes (x = Response, y = Aitchison_distance)) + 
#   geom_boxplot() + 
#   geom_jitter(aes(color = ATB_use)) + 
#   geom_text_repel(aes (label = Sample)) 


#Boxplot 
aitchison_df %>% pivot_longer(cols = contains("DRUP"), names_to = "Sample2", values_to = "Aitchison_distance") %>% left_join(., (final_metadata %>% select (Sample, patientId, Response, timepoint, ATB_use))) %>%
left_join(., (final_metadata %>% select (Sample, patientId) %>% rename (patientId2 = patientId)), by = c("Sample2" = "Sample")) %>%
mutate (same_patient = ifelse (patientId == patientId2, "Same patient", "Random")) %>% filter (Sample != Sample2) %>% filter (timepoint== "T1") %>% 
ggplot (aes (x = same_patient, y = Aitchison_distance)) + 
  #geom_jitter(aes(color = ATB_use)) + 
ylab ("Aitchison distance T1-T2")+
stat_compare_means(comparisons = list(c("Random", "Same patient")),label = "p.signif", size = 5  )+
theme_classic(base_size = 16) + 
xlab("")+
geom_boxplot(aes (fill = same_patient), show.legend = FALSE)

ggsave("Aitchison_random_paired.png", path = path_plots, height = 4.1, width = 4)

```



###UMAPS
```{r}

#Calculation of the UMAP
umap_abundance <- umap (as.matrix(abundance_prot_families_mt_clr))

#Generate table with UMAP1 and 2 with other variables for plotting. 
umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename(UMAP1="V1",UMAP2="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% left_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use", "tumor_groups") ))) %>% mutate (, Id_num = as.numeric(factor(.$patientId)))


umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Timepoint
umap_plot2 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = timepoint)) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Batch
umap_plot3 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Batch)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Tumor_group
umap_plot4 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( aes (color = tumor_groups)) +
  labs (color = "Tumor groups")+
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  labs (color = "Patient id")+
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
    labs (color = "ATB use") + 
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Clinical Benefit
umap_plot7 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = CB)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


path_umaps_plots <- "/home/m.p.martinez/fun_profiling/plots/metawibele/run2/umaps"

umap_plot1
ggsave("umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot2
ggsave("umap_abundance_timepoint.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot3
ggsave("umap_abundance_batch.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot4
ggsave("umap_abundance_tumortype.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot7
ggsave("umap_abundance_cb.png", path = path_umaps_plots, height = 4, width = 6)

```


```{r}
## Time drive based on ATB for last UMAP. 

#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#antibiotic use ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(  show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  labs (color = "ATB use")+
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16)) +
  scale_color_manual(values=c("black", "purple"))  #theme(text = element_text(size=12))

ggsave("umap_abundance_atb_lines.png", path = path_umaps_plots, height = 4, width = 6)




#Response line
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(  show.legend = TRUE, aes (shape = timepoint, color = Response)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("umap_abundance_response_lines.png", path = path_umaps_plots, height = 4, width = 6)


#Bor line
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(  show.legend = TRUE, aes (shape = timepoint, color = BOR)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = BOR), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("umap_abundance_BOR_lines.png", path = path_umaps_plots, height = 4, width = 6)



```




*UMAP* using protein abundance based on the homology classification. 

####- No homology: 
```{r}

#Filter abundance for only protein clusters with no homology. 
abundance_prot_nh <- homology_abun_per_sample3 %>% filter (homology == "NH") %>% column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()


umap_abundance_nh <- umap (as.matrix(abundance_prot_nh))


umap_df_nh <- umap_abundance_nh$layout %>% as_tibble() %>% rename ("UMAP1" = "V1", "UMAP2" = "V2") %>% add_column (Sample = rownames (umap_abundance_nh$layout), .before = 1) %>% inner_join (., (final_metadata %>% select (c ("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use"))))
umap_mean_sample_nh <- umap_df_nh %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df_nh <- umap_df_nh %>% left_join (., umap_mean_sample_nh)

#Response
umap_plot1 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme(text = element_text(size=12))


#Patient ID
umap_plot5 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample_nh, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) 
  #theme(text = element_text(size=12))


#Antibiotics use
umap_plot6 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme(text = element_text(size=12))



umap_plot1
ggsave("NH-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("NH-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("NH-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)




```


####-Remote homology
Making the UMAP only with the clusters of proteins with Remote homology. 
```{r}
#Filter for remote homology
abundance_prot_homology_filtered <- homology_abun_per_sample3 %>% filter (homology == "RH") %>% column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme(text = element_text(size=12))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) 
  #theme(text = element_text(size=12))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme(text = element_text(size=12))



umap_plot1
ggsave("RH-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("RH-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("RH-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)


```


####-Strong homology
Strong homology. 
```{r}
#Filter for strong homology
abundance_prot_homology_filtered <- homology_abun_per_sample3 %>% filter (homology %in% c ("SC", "SU")) %>% column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4)+
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



umap_plot1
ggsave("SH-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("SH-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("SH-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)


#Patient drive over time based on antibiotic use
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("SH-umap_abundance_atb_lines.png", path = path_umaps_plots, height = 4, width = 6)



```




```{r}
#Patient ID
umap_df %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))
```






####-High prevalence
*UMAP* only for the proteins with high prevalence (>0.3)

```{r}
#Filter for high prevalence
abundance_prot_homology_filtered <- homology_abun_per_sample3  %>% mutate (prevalence = as.double(prevalence)) %>% filter (prevalence >= 0.5) %>% column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4)+ 
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))




umap_plot1
ggsave("HPrevalence-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("HPrevalence-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("HPrevalence-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)


#Patient drive over time based on antibiotic use
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("HPrevalence-umap_abundance_atb_lines.png", path = path_umaps_plots, height = 4, width = 6)



#Patient drive over time based on response
umap_df %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE, aes(color = Response)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("HPrevalence-umap_abundance_response_lines.png", path = path_umaps_plots, height = 4, width = 6)



#Groups with elipses
umap_df %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( aes(color = Response, shape = timepoint)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

ggsave("HPrevalence-umap_abundance_response_lines_elipses.png", path = path_umaps_plots, height = 4, width = 6)













```




####-Low prevalence
*UMAP* only for the proteins with low prevalence (<0.15)

```{r}
#Filter for high prevalence
abundance_prot_homology_filtered <- homology_abun_per_sample3  %>% mutate (prevalence = as.double(prevalence)) %>% filter (prevalence <= 0.15) %>% column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4)+ 
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



umap_plot1
ggsave("LPrevalence-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("LPrevalence-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("LPrevalence-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)



#Patient drive over time based on antibiotic use
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


ggsave("LPrevalence-umap_abundance_atb_lines.png", path = path_umaps_plots, height = 4, width = 6)


#Patient drive over time based on response
umap_df %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = FALSE, aes(color = Response)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


ggsave("LPrevalence-umap_abundance_response_lines.png", path = path_umaps_plots, height = 4, width = 6)


# Cluster groups with elipses
umap_df %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( aes(color = Response, shape = timepoint)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  stat_ellipse(data = (. %>% filter (Response == "Responder")), aes( color = Response), linetype = "dashed") +
  stat_ellipse(data = (. %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))

path_umaps_plots <- "/home/m.p.martinez/fun_profiling/plots/metawibele/run2/umaps"
ggsave("LPrevalence-umap_abundance_response_lines_elipses.png", path = path_umaps_plots, height = 4, width = 6)

```









30/01/2023----------------- 

Name assignations are a bit confusion here. 


####-Prevalence filter
UMAPs with the protein clusters filtered by prevalence 
Selection of clusters by prevalence: 
```{r}

#Select clusters that are only present in 50% sampels in one of the groups or >30% in both groups.
abun_per_sample3_prev_filtered <- homology_abun_per_sample3 %>% filter ((`DNA-Non-responder_prevalence` > 0.5 | `DNA-Responder_prevalence` > 0.5) | (`DNA-Non-responder_prevalence` > 0.3 & `DNA-Responder_prevalence` > 0.3)) 
dim (abun_per_sample3_prev_filtered)


abun_per_sample3_prev_filtered %>% ggplot(aes (x = homology)) + geom_bar(aes(fill = homology))

```


```{r}
#Filter abundance for only protein clusters with no homology. 
abundance_prot_nh <- abun_per_sample3_prev_filtered %>%  column_to_rownames("familyID") %>% select (contains("DRUP0")) %>% as.matrix() %>% t() %>% clr()


umap_abundance_nh <- umap (as.matrix(abundance_prot_nh))


umap_df_nh <- umap_abundance_nh$layout %>% as_tibble() %>% rename ("UMAP1" = "V1", "UMAP2" = "V2") %>% add_column (Sample = rownames (umap_abundance_nh$layout), .before = 1) %>% inner_join (., (final_metadata %>% select (c ("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use"))))
umap_mean_sample_nh <- umap_df_nh %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df_nh <- umap_df_nh %>% left_join (., umap_mean_sample_nh)

#Response
umap_plot1 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme(text = element_text(size=12))


#Patient ID
umap_plot5 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample_nh, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) 
  #theme(text = element_text(size=12))


#Antibiotics use
umap_plot6 <- umap_df_nh %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme(text = element_text(size=12))



umap_plot1
umap_plot5
umap_plot6
```




####-Only T1

```{r}
#Filter for high prevalence
abundance_prot_homology_filtered <- homology_abun_per_sample3 %>% column_to_rownames("familyID") %>% select ((final_metadata %>% filter (timepoint == "T1") %>% pull (Sample))) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4)+ 
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



umap_plot1
ggsave("T1revalence-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("T1revalence-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("T1revalence-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)



```



####-Only T2

```{r}
#Filter for high prevalence
abundance_prot_homology_filtered <- homology_abun_per_sample3 %>% column_to_rownames("familyID") %>% select ((final_metadata %>% filter (timepoint == "T2") %>% pull (Sample))) %>% as.matrix() %>% t() %>% clr()

umap_abundance <- umap (as.matrix(abundance_prot_homology_filtered))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4)+ 
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



umap_plot1
ggsave("T2-umap_abundance_response.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot5
ggsave("T2-umap_abundance_patientid.png", path = path_umaps_plots, height = 4, width = 6)
umap_plot6
ggsave("T2-umap_abundance_antibiotics.png", path = path_umaps_plots, height = 4, width = 6)



```



## Prioritazion outputs
```{r}

### Prioritize outputs: 
#prioritize_selected_sup_table <- read_tsv("/home/m.p.martinez/fun_profiling/metawibele/output/run2/prioritization.1/metawibele_supervised_prioritization.rank.selected.table.tsv")
prioritize_selected_sup <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run2/prioritization.1/metawibele_supervised_prioritization.rank.selected.tsv")
#prioritize_selected_unsup_table <- read_tsv ("/home/m.p.martinez/fun_profiling/metawibele/output/run1/prioritization2/metawibele_unsupervised_prioritization.rank.selected.table.tsv")

```


Creation of a new abundace df with the abundance CLR normalized
```{r}

#Same as homology abundace data frame but with CLR normalized abundance data
homology_abun_per_sample4 <- homology_abun_per_sample3 %>% select (! contains ("DRUP0"))

homology_abun_per_sample4 <- left_join( homology_abun_per_sample4, (t(abundance_prot_families_mt_clr) %>% as_tibble(rownames = NA) %>% rownames_to_column() %>% rename (familyID = rowname)))

homology_abun_per_sample4 <- left_join (homology_abun_per_sample4, (annotation %>% filter (feature == "MSPminer_MSP") %>% select (c ("familyID", "annotation")) %>% rename (pangenome = annotation) ))

saveRDS(homology_abun_per_sample3, "./R_objects/homology_abun_per_sample3.rds")

```



### Heatmaps prioritization

```{r}
library ("ComplexHeatmap")
library ("tidyHeatmap")
```

####Heatmap top 30 supervised
```{r}


#Select the top 30 protein families prioritized...
familyID_prior_sup <- prioritize_selected_sup %>% head (n = 30) %>% separate (col = familyID, into = c ("familyID", "category"), sep = "\\|") %>% pull (familyID)


#Construction of the heatmap df
heatmap_df <- homology_abun_per_sample4 %>%
  filter (familyID %in% familyID_prior_sup) %>%
  select (-setdiff( (homology_abun_per_sample4 %>%
                       select (contains ("DRUP")) %>% colnames()), final_metadata$Sample)) %>%
  pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "LCR") %>%
  left_join(., (final_metadata %>%
                  select (Sample, Response, timepoint))) %>%
  replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>%
  rename (TM_domain = denovo_transmembrane, Signaling_domain = denovo_signaling) %>%
  mutate (TM_domain = replace (TM_domain, TM_domain == "Denovo_transmembrane", "Yes"), Signaling_domain = replace (Signaling_domain, Signaling_domain == "Denovo_signaling", "Yes")) 


#Construction of the heatmap
heatmap_df %>% replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>% rename ("Protein family" = "familyID") %>%  group_by (Response) %>%
  heatmap (`Protein family`, Sample, LCR,
           scale = "row",
           #show_row_dend = FALSE,
           show_column_dend = FALSE,
           show_column_names = FALSE,
           #palette_grouping = list(c ("black", "grey30")),
           heatmap_width = unit(10, "npc"),
           heatmap_height = unit (15, "npc"),
           row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>%
  annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
  annotation_tile (Signaling_domain, palette = c("Yellowgreen", "Gray")) %>%
  annotation_tile(TM_domain, palette = c("Gray", "Yellowgreen"), annotation_name_gp = gpar (fontface = "bold"))  %>%
  annotation_tile (Response) %>% 
  as_ComplexHeatmap() %>%
    ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")




```

```{r}
heatmap_df <- homology_abun_per_sample3 %>% filter (familyID %in% familyID_prior_sup) %>% pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "cpm") %>% left_join(., (final_metadata %>% select (Sample, Response, timepoint)))



#Construction of the heatmap
heatmap_df %>% group_by (Response) %>%  heatmap (familyID, Sample, cpm, scale = "row",  show_row_dend = FALSE, show_column_dend = FALSE,
                                                 show_column_names = FALSE,
                                                 palette_grouping = list(c ("black", "grey30")),
                                                 heatmap_width = unit(10, "npc"),
                                                 heatmap_height = unit (15, "npc"), 
                                                 row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>% annotation_tile(homology) %>% annotation_tile (timepoint) %>% as_ComplexHeatmap() 
```



Take a look to the distribution of abundance for each protein clutsers in each sample (seems very variable)??

Add new tile with transmebrane/signaling yes or no. 



####Haetmap strong homology
Heatmap but only for the most prioritized protein clusters with strong homology (clusters that are annotated.)
```{r}

#Select top 30 clusters with SC homology (with annotations)
familyID_prior_sup <- prioritize_selected_sup  %>% separate (col = familyID, into = c ("familyID", "category"), sep = "\\|") 
familyID_prior_sup <- left_join (familyID_prior_sup, (homology_abun_per_sample4 %>% select (c ("familyID", "homology")))) %>% filter (homology == "SC") %>% head(30) %>% pull(familyID) 

#Construction of the heatmap df
  #Selection only of the top results. 
heatmap_df <- homology_abun_per_sample4 %>% filter (familyID %in% familyID_prior_sup) %>% pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "LCR") %>% left_join(., (final_metadata  %>% select (Sample, Response)))


#Construction of the heatmap
heatmap_df %>% group_by (Response) %>%  heatmap (familyID, Sample, LCR, scale = "row", 
                                                 show_row_dend = FALSE, show_column_dend = FALSE,
                                                 show_column_names = FALSE,
                                                 palette_grouping = list(c ("black", "grey30")),
                                                 heatmap_width = unit(10, "npc"),
                                                 heatmap_height = unit (15, "npc"),
                                                 row_names_max_width = unit (10, "cm"),
                                                 row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>% 
  as_ComplexHeatmap() %>% ComplexHeatmap::draw(heatmap_legend_side = "left"   )

```

```{r}

```





##Satatistical analysis: Limma
```{r}

colnames (abundance_prot_families_mt)
PCs_abundance %>% pull (Sample) %>% factor ()

plotMDS (abundance_prot_families_mt, col = as.numeric(factor(PCs_abundance$Response)))
plotMDS( abundance_prot_families_mt, col = as.numeric (factor (PCs_abundance$Response)), top = 1000, gene.selection = "common")

```
?? meaning of this compared with the PCA??.. Is PCoA using the distance between samples only of the "top" n genes. The top genes in this case with largest standard variation. 




### ~reponse + tumor_type

Statistical analysis filtering the protein families by abundance and by annotation (only of protein families SC or with predicted TM or signaling domains)
```{r}

#Samples analyzed  
samples <- abundance_prot_families_mt %>% colnames() %>% as.factor()

response_group <- tibble (Sample = colnames (abundance_prot_families_mt)) %>% inner_join(., (final_metadata %>% select (Sample, Response))) %>% mutate (Response = make.names (Response)) %>% pull(Response) %>% as.factor()

timepoint_group <- tibble (Sample = colnames (abundance_prot_families_mt)) %>% inner_join (., (final_metadata %>% select (Sample, timepoint))) %>% mutate (timepoint = make.names (timepoint)) %>% pull (timepoint) %>% as.factor()

tumortype_group <- tibble (Sample = colnames (abundance_prot_families_mt)) %>% inner_join (., (final_metadata %>% select (Sample, tumor_type))) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()

patient_group <- final_metadata$patientId %>% as.factor()



# Addition of columns for signaling and TM domain prediction for each protein family
homology_abun_per_sample3 <- homology_abun_per_sample3 %>% left_join (., (annotation %>% filter (method == "SignalP/Phobius") %>% select (familyID, feature) %>% rename (denovo_signaling = feature))) %>% left_join (., (annotation %>% filter (method == "TMHMM/Phobius") %>% select (familyID, feature) %>% rename (denovo_transmembrane = feature))) 

#Select only protein families with annotations or with prediction of signaling/TM domain. 
families_filter <- homology_abun_per_sample3 %>% filter (homology == "SC" | !is.na(denovo_signaling) | !is.na(denovo_transmembrane) ) %>% group_by(homology) %>% pull (familyID)



#Responder and non Responders samples
R_samples <- final_metadata %>% filter (Response == "Responder") %>% pull(Sample)
NR_samples <- final_metadata %>% filter (Response == "Non-responder") %>% pull(Sample)

# Add columns for mean expression in each group. 
homology_abun_per_sample3 <- homology_abun_per_sample3 %>% mutate (mean_abun_responders =  (homology_abun_per_sample3 %>% select (all_of(R_samples)) %>% rowMeans())) %>% mutate ( mean_abun_non_responders = (homology_abun_per_sample3 %>% select (all_of(NR_samples)) %>% rowMeans()))




#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select (final_metadata$Sample) %>% as.matrix





#filter <- filterByExpr(abundance_prot_families_mt, mm, min.count = 3, large.n = 25)

#model matrix
mm <- model.matrix (~0 + response_group + tumortype_group)

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(response_groupNon.responder - response_groupResponder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table


```

Only protein families that are SC or have a predicted signaling/TM domain are included. 
From those, only the ones with a mean abundance > 3 in either Responder or non responder are included. 

```{r}
vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
            

vp
```












### ~ response + tumotype + timepoint + patient

```{r}
#model matrix
mm <- model.matrix (~0 + response_group + tumortype_group + timepoint_group + patient_group)

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(response_groupNon.responder - response_groupResponder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
            

vp

```






### T1 only (~ response + tumor_type + ATB_use)

```{r}

#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T1 <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T1")) %>% pull(Sample)) %>% as.matrix()

# tumortype_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()

#antibiotic_group_T1 <- 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

# mm <- model.matrix (~0 + Response + tumor_groups + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_groups = make.names(tumor_groups))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T1_limma_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)


```
No significant associations if the tumor_groups variables is used instead of tumor_type









#####-Heatmap of top results: 
```{r}
#Select the top 30 protein families prioritized...

familyID_prior_sup <- top.table %>% as_tibble(rownames = NA) %>% rownames_to_column(var = "familyID") %>% arrange (P.Value) %>% head(n = 30) %>% pull (familyID)

 #Construction of the heatmap df
heatmap_df <- homology_abun_per_sample3 %>%
  filter (familyID %in% familyID_prior_sup) %>%
  pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "cpm") %>%
  left_join(., (final_metadata %>%
                  select (Sample, Response, timepoint))) %>%
  replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>%
  rename (TM_domain = denovo_transmembrane, Signaling_domain = denovo_signaling) %>%
  mutate (TM_domain = replace (TM_domain, TM_domain == "Denovo_transmembrane", "Yes"), Signaling_domain = replace (Signaling_domain, Signaling_domain == "Denovo_signaling", "Yes")) 

#Construction of the heatmap (filtering only for T1 samples)
heatmap_df %>% replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>% rename ("Protein family" = "familyID") %>%  filter (timepoint == "T1") %>%
  mutate (z_score = log2(cpm+0.01)) %>% group_by (Response) %>%
  heatmap (`Protein family`, Sample, z_score,
           scale = "row",
           #show_row_dend = FALSE,
           show_column_dend = FALSE,
           show_column_names = FALSE,
           #palette_grouping = list(c ("black", "grey30")),
           heatmap_width = unit(10, "npc"),
           heatmap_height = unit (15, "npc"),
           row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>%
  #annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
  annotation_tile (Signaling_domain, palette = c("lightblue", "blueviolet")) %>%
  annotation_tile(TM_domain, palette = c("lightblue", "blueviolet"), annotation_name_gp = gpar (fontface = "bold"))  %>%
  annotation_tile (Response, palette = c("brown4", "olivedrab")) %>% 
   annotation_tile (homology) %>%
  as_ComplexHeatmap() %>%
    ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")


```
Heatmap of the most significantive protein families in the DA abundance at T1. 







#### T1 only SC proteins (~ response + tumor_type + ATB_use)

Only the SC proteins have GO annotations

```{r}

#Generation of the matrix with the protein families (only SC protein families) and the samples filtered. 
abundance_prot_families_mt_filter_T1 <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter ( homology == "SC") %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T1")) %>% pull(Sample)) %>% as.matrix()

# tumortype_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()
# 
# #model matrix
# mm <- model.matrix (~0 + response_group_T1 + tumortype_group_T1 )

#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table
top.table <- top.table %>% rownames_to_column(var = "familyID")

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp


vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T1_limma_SCprots_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)



```



######Top Go analysis: 
```{r}
top_go_terms_df <- annotation %>% filter (familyID %in% (top.table %>% arrange(adj.P.Val) %>% filter (adj.P.Val < 0.05) %>% pull (familyID))) %>% filter (feature == "UniRef90_GO") %>% dplyr::select (familyID, annotation) %>% dplyr::rename (go_terms = annotation)


homology_abun_per_sample3 <- homology_abun_per_sample3 %>% left_join(., (annotation %>% filter (feature =="UniRef90_GO") %>% dplyr::select (familyID, annotation) %>% dplyr::rename (go_terms = annotation)))



homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% select (familyID, homology, go_terms) %>% group_by (homology)



# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% top.table$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")


## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse (top.table$adj.P.Val < 0.05, 1, 0)
names(gene_list_go) <- top.table$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)
tab %>% View()



showSigOfNodes(GOdata, score(resultFisher), firstSigNodes = 3, useInfo = "def")

```
t-test to each go term can be performed to check if it is present more time in the different 


Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  scale_color_continuous(trans = "log", breaks = c(1,2,4,8,16) ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```
Would be better to do a lollipop plot with coloring of the fold enrichment, -log(10, pval) and size as the number of genes. 



This does not work....
```{r}
## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- top.table$P.Value
names(gene_list_go) <- top.table$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)x,
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultKS <- runTest(GOdata, algorithm = "weight01", statistic = "ks")

tab <- GenTable(GOdata, raw.p.value = resultKS, topNodes = length(resultKS@score), numChar = 120)

tab %>% View()
```





#### T1 only KEGG proteins (~ response + tumor_type + ATB_use)

```{r}
#Generation of the matrix with the protein families (only SC protein families) and the samples filtered. 
abundance_prot_families_mt_filter_T1 <- homology_abun_per_sample3 %>%
  column_to_rownames(var = "familyID") %>%
  filter (KEGG_KOs != NaN) %>%
  select (final_metadata %>%
             filter (timepoint == "T1") %>% pull(Sample))  %>%
  mutate(mean = rowMeans(.)) %>%
  filter (mean > 3) %>%
  select (-mean) %>% 
  as.matrix()



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))


#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)





head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table
top.table <- top.table %>% rownames_to_column(var = "familyID")

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
```



### New prevalence filter 


#### T1 only (new filter by prevalence)

Selecting all the proteins (SC, SU and the ones with TM and SD annotations) 
(~ response + tumor_type + ATB_use)
```{r}


#Add a column of prevalence 
homology_abun_per_sample3$prevalence_T1 <- rowSums (homology_abun_per_sample3 %>% select (contains("DRUP") & contains("T1")) > 0 ) / dim(final_metadata %>% filter (timepoint == "T1"))[1]

homology_abun_per_sample3$mean_T1 <- rowMeans (homology_abun_per_sample3 %>% select (contains("DRUP") & contains("T1")) ) 


#Select only protein families with annotations or with prediction of signaling/TM domain. 
families_filter <- homology_abun_per_sample3 %>% filter (homology %in% c("SC", "SU") | !is.na(denovo_signaling) | !is.na(denovo_transmembrane) ) %>% pull (familyID)


#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T1 <- homology_abun_per_sample3 %>% filter (prevalence_T1 > 0.30 & mean_T1 > 0.40 ) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T1")) %>% pull(Sample)) %>% as.matrix()


# tumortype_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()

#antibiotic_group_T1 <- 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

# mm <- model.matrix (~0 + Response + tumor_groups + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_groups = make.names(tumor_groups))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 15), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

path_DA = "/home/m.p.martinez/fun_profiling/plots/metawibele/run2/DA_new_filter"

ggsave("T1_limma_response_tumortype_atb_use.png", path = path_DA, height = 4, width = 6)



vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

```





#### T2 only (new filter by prevalence)

(~ response + tumor_type + ATB_use)
```{r}


#Add a column of prevalence 
homology_abun_per_sample3$prevalence_T2 <- rowSums (homology_abun_per_sample3 %>% select (contains("DRUP") & contains("T2")) > 0 ) / dim(final_metadata %>% filter (timepoint == "T2"))[1]

homology_abun_per_sample3$mean_T2 <- rowMeans (homology_abun_per_sample3 %>% select (contains("DRUP") & contains("T2")) ) 


#Select only protein families with annotations or with prediction of signaling/TM domain. 
families_filter <- homology_abun_per_sample3 %>% filter (homology %in% c("SC", "SU") | !is.na(denovo_signaling) | !is.na(denovo_transmembrane) ) %>% pull (familyID)


#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T2 <- homology_abun_per_sample3 %>% filter (prevalence_T2 > 0.30 & mean_T2 > 0.40 ) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T2")) %>% pull(Sample)) %>% as.matrix()



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T2") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

# mm <- model.matrix (~0 + Response + tumor_groups + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_groups = make.names(tumor_groups))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T2, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T2_limma_response_tumortype_atb_use.png", path = path_DA, height = 4, width = 6)


vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

```

Fraction of proteins differentially abundant that have transmembrane and signaling domain.
```{r}
top.table <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, denovo_signaling, denovo_transmembrane, homology))

top.table

#Non-responders
top.table %>% filter (adj.P.Val < 0.05 & logFC > 1) %>% group_by (denovo_transmembrane) %>% summarise (n = n(), per = n/dim(top.table %>% filter (adj.P.Val < 0.05 & logFC > 1))[1])

top.table %>% filter ((adj.P.Val < 0.05 & logFC > 1))  %>% group_by (denovo_signaling) %>% summarise (n = n(),per = n/dim(top.table %>% filter (adj.P.Val < 0.05 & logFC > 1))[1])

#Responders
top.table %>% filter (adj.P.Val < 0.05 & logFC < 1) %>% group_by (denovo_transmembrane) %>% summarise (n = n(), per = n/dim(top.table %>% filter (adj.P.Val < 0.05 & logFC < 1))[1])

top.table %>% filter ((adj.P.Val < 0.05 & logFC < 1))  %>% group_by (denovo_signaling) %>% summarise (n = n(), per = n/dim(top.table %>% filter (adj.P.Val < 0.05 & logFC < 1))[1])

#All protein clusters analyzed
top.table  %>% group_by (denovo_transmembrane) %>% summarise (n = n(), per = n/dim(top.table)[1])
top.table  %>% group_by (denovo_signaling) %>% summarise (n = n(), per = n/dim(top.table)[1])


```










#### T1 only only SC
```{r}

#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T1 <- homology_abun_per_sample3 %>% filter (prevalence_T1 > 0.30 & mean_T1 > 0.40 ) %>% filter (homology == "SC") %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T1")) %>% pull(Sample)) %>% as.matrix()


# tumortype_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T1 <- final_metadata %>% filter (timepoint == "T1") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()

#antibiotic_group_T1 <- 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

# mm <- model.matrix (~0 + Response + tumor_groups + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_groups = make.names(tumor_groups))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table_t1 <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table_t1

vp <- top.table_t1 %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T1_SC_limma_response_tumortype_atb_use.png", path = path_DA, height = 4, width = 5)


vp <- top.table_t1 %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
  #geom_text_repel(data = . %>% filter (-log(P.Value,10) > 5), aes (x = logFC, y = -log(P.Value,10), label = protein_name)) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

```

```{r}

top.table_t1 %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, go_terms)) %>% View() 

```

top.table_t1 %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) 


######Top Go analysis: 

Enriched in non-responders
```{r}

# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% top.table_t1$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")


top.table_t1 <- top.table_t1 %>% rownames_to_column(var = "familyID")

## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse ((top.table_t1$adj.P.Val < 0.05 & top.table_t1$logFC > 0), 1, 0)
names(gene_list_go) <- top.table_t1$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


```
t-test to each go term can be performed to check if it is present more time in the different 

Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Significant > 2) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  scale_color_continuous(trans = "log", breaks = c(1,2,4,8,16) ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```
Enriched in responders
```{r}

# Save the GO_terms from the protein families used for the limma-voom analysis. 

#top.table <- top.table %>% rownames_to_column(var = "familyID")

## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse ((top.table_t1$adj.P.Val < 0.05 & top.table_t1$logFC < 0), 1, 0)
names(gene_list_go) <- top.table_t1$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


```
t-test to each go term can be performed to check if it is present more time in the different 

Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Significant > 2) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  #scale_color_continuous(trans = "log", breaks = c(1,2,4,8,16) ) +
  #scale_color_continuous()+
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```


####T2 only SC
```{r}


#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T2 <- homology_abun_per_sample3 %>% filter (prevalence_T2 > 0.30 & mean_T2 > 0.40 ) %>% filter (homology == "SC") %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T2")) %>% pull(Sample)) %>% as.matrix()



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T2") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

# mm <- model.matrix (~0 + Response + tumor_groups + ATB_use,  data = (final_metadata %>% filter (timepoint == "T1") %>% mutate (Response = make.names(Response), tumor_groups = make.names(tumor_groups))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T2, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T2_SC_limma_response_tumortype_atb_use.png", path = path_DA, height = 4, width = 5)


vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp


top.table_t2 <- top.table %>% rownames_to_column(var = "familyID")
```

######Top Go analysis: 
Enriched in non-responders
```{r}

# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% top.table_t2$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")


#top.table <- top.table %>% rownames_to_column(var = "familyID")

## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse ((top.table_t2$adj.P.Val < 0.05 & top.table_t2$logFC > 0), 1, 0)
names(gene_list_go) <- top.table_t2$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


```
t-test to each go term can be performed to check if it is present more time in the different 

Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Significant > 2) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  scale_color_continuous(trans = "log", breaks = c(1,2,4,8,16) ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```


Enriched in responders
```{r}


#top.table <- top.table %>% rownames_to_column(var = "familyID")

## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse ((top.table_t2$adj.P.Val < 0.05 & top.table_t2$logFC < 0), 1, 0)
names(gene_list_go) <- top.table_t2$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


```
t-test to each go term can be performed to check if it is present more time in the different 

Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Significant > 2) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  #scale_color_continuous(trans = "log", breaks = c(0.5,1.2,2,3,4,8,16) ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```






### T2 only (~ response + tumor_type + ATB_use)

```{r}
#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter_T2 <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T2")) %>% pull(Sample)) %>% as.matrix()
# 
# tumortype_group_T2 <- final_metadata %>% filter (timepoint == "T2") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T2 <- final_metadata %>% filter (timepoint == "T2") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T2") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T2, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table


vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp


vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T2_limma_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)
```


#####-Heatmap of top results: 
```{r}
#Select the top 30 protein families prioritized...

familyID_prior_sup <- top.table %>% as_tibble(rownames = NA) %>% rownames_to_column(var = "familyID") %>% arrange (P.Value) %>% head(n = 30) %>% pull (familyID)

 #Construction of the heatmap df
heatmap_df <- homology_abun_per_sample3 %>%
  filter (familyID %in% familyID_prior_sup) %>%
  pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "cpm") %>%
  left_join(., (final_metadata %>%
                  select (Sample, Response, timepoint))) %>%
  replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>%
  rename (TM_domain = denovo_transmembrane, Signaling_domain = denovo_signaling) %>%
  mutate (TM_domain = replace (TM_domain, TM_domain == "Denovo_transmembrane", "Yes"), Signaling_domain = replace (Signaling_domain, Signaling_domain == "Denovo_signaling", "Yes")) 

#Construction of the heatmap (filtering only for T1 samples)
heatmap_df %>% replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>% rename ("Protein family" = "familyID") %>%  filter (timepoint == "T1") %>%
  mutate (z_score = log2(cpm+0.01)) %>% group_by (Response) %>%
  heatmap (`Protein family`, Sample, z_score,
           scale = "row",
           #show_row_dend = FALSE,
           show_column_dend = FALSE,
           show_column_names = FALSE,
           #palette_grouping = list(c ("black", "grey30")),
           heatmap_width = unit(10, "npc"),
           heatmap_height = unit (15, "npc"),
           row_names_max_width = unit(10, "cm"),
           row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>%
  #annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
  annotation_tile (Signaling_domain, palette = c("lightblue", "blueviolet")) %>%
  annotation_tile(TM_domain, palette = c("lightblue", "blueviolet"), annotation_name_gp = gpar (fontface = "bold"))  %>%
  annotation_tile (Response, palette = c("brown4", "olivedrab")) %>% 
   annotation_tile (homology) %>%
  as_ComplexHeatmap() %>%
    ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")


```

####T2 only SC proteins 
```{r}
#Generation of the matrix with the protein families (only SC protein families) and the samples filtered. 
abundance_prot_families_mt_filter <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter ( homology == "SC") %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (timepoint == "T2")) %>% pull(Sample)) %>% as.matrix()


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T2") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table
top.table <- top.table %>% rownames_to_column(var = "familyID")


vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp


vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("T2_limma_SCprots_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)


```



####Top Go analysis: 

#####NR increased GO pathways T2. 
```{r}

#Only the ones enriched in non responders
top_go_terms_df <- annotation %>% filter (familyID %in% (top.table %>% arrange(adj.P.Val) %>% filter (adj.P.Val < 0.05 & logFC > 0) %>% pull (familyID))) %>% filter (feature == "UniRef90_GO") %>% dplyr::select (familyID, annotation) %>% dplyr::rename (go_terms = annotation)


# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% top.table$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")


## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse (top.table$adj.P.Val < 0.05 & top.table$logFC > 0, 1, 0)
names(gene_list_go) <- top.table$familyID

#Creation of teh GO data object
GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)

#Geneartion of test comparing the probability of being in the eriched side of the non responders
resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

# tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
#   ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
#   geom_col(aes(fill = "Red"), show.legend = FALSE) + 
#   ylab("Biological process") +
#   xlab("Enrichment") +
#   theme_bw() +
#   theme(
#     panel.grid.major = element_blank(), 
#     panel.grid.minor = element_blank(), 
#     text = element_text(size = 16)
#   )



tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected ))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  scale_color_continuous(trans = "log" , breaks = c(2,4,8,16), labels = c(2,4,8,16), lim = c(1,18) )+
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 16)
  )


```




#####R increased GO pathways T2. 
```{r}

#Only the ones enriched in non responders
top_go_terms_df <- annotation %>% filter (familyID %in% (top.table %>% arrange(adj.P.Val) %>% filter (adj.P.Val < 0.05 & logFC < 0) %>% pull (familyID))) %>% filter (feature == "UniRef90_GO") %>% dplyr::select (familyID, annotation) %>% dplyr::rename (go_terms = annotation)


# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% top.table$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")


## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse (top.table$adj.P.Val < 0.05 & top.table$logFC < 0, 1, 0)
names(gene_list_go) <- top.table$familyID

#Creation of teh GO data object
GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)

#Geneartion of test comparing the probability of being in the eriched side of the non responders
resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

# tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
#   ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
#   geom_col(aes(fill = "Red"), show.legend = FALSE) + 
#   ylab("Biological process") +
#   xlab("Enrichment") +
#   theme_bw() +
#   theme(
#     panel.grid.major = element_blank(), 
#     panel.grid.minor = element_blank(), 
#     text = element_text(size = 16)
#   )



tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected ))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  scale_color_continuous(trans = "log" , breaks = c(2,4,8,16), labels = c(2,4,8,16), lim = c(1,18) )+
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text = element_text(size = 16)
  )
```




####T2 only KEGG proteins (~ Response + tumor_type + ATB_use)
```{r}
#Generation of the matrix with the protein families (only SC protein families) and the samples filtered. 
abundance_prot_families_mt_filter <- homology_abun_per_sample3 %>%
  column_to_rownames(var = "familyID") %>%
  filter (KEGG_KOs != NaN) %>%
  select (final_metadata %>%
             filter (timepoint == "T2") %>% pull(Sample))  %>%
  mutate(mean = rowMeans(.)) %>%
  filter (mean > 3) %>%
  select (-mean) %>% 
  as.matrix()



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use,  data = (final_metadata %>% filter (timepoint == "T2") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))


#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)





head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table
top.table <- top.table %>% rownames_to_column(var = "familyID")

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- top.table %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (adj.P.Val < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Responders vs Non-responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp




```

```{r}
homology_abun_per_sample3 %>% filter (familyID %in% (top.table %>% filter (P.Value < 0.05 & logFC < 0) %>% pull (familyID))) %>% select (familyID, KEGG_KOs) %>% write_tsv("KeGG_anotations.tsv", col_names = FALSE) 

listDatabases()

keggGet(c("K12112", "K14762", "K09901"))
```



###T1 only ( ~ response)
```{r}
#model matrix
mm <- model.matrix (~0 + response_group_T1 )

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter_T1, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(response_group_T1Non.responder - response_group_T1Responder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
## Plot of the pvalue not the adjusted pvalue.  
```
There are also more protein families overexpresed in the Non-response conditicion compared with the Responders. If the adjusted p-val is ploted (some of the p-values are stratified. ) none of the proteins families reach significance. 



### Non-Responders (~ response + tumor_type + ATB_use)

```{r}
#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (Response == "Non-responder")) %>% pull(Sample)) %>% as.matrix()
# 
# tumortype_group_T2 <- final_metadata %>% filter (timepoint == "T2") %>%  select (Sample, tumor_type) %>% mutate (tumor_type = make.names(tumor_type)) %>%  pull (tumor_type) %>% as.factor()
# 
# response_group_T2 <- final_metadata %>% filter (timepoint == "T2") %>%  select (Sample, Response) %>% mutate (Response = make.names(Response)) %>%  pull (Response) %>% as.factor()



#model matrix
mm <- model.matrix (~0 + timepoint + tumor_type + ATB_use,  data = (final_metadata %>% filter (Response == "Non-responder") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(timepointT1 - timepointT2, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
```
No significative differences between the non responders in both times. 



Non-Responders KEGG
```{r}

```


### Responders only: 

```{r}
#Generation of the matrix with the protein families and the samples filtered. 
abundance_prot_families_mt_filter <- homology_abun_per_sample3 %>% filter (mean_abun_responders > 3 | mean_abun_non_responders > 3) %>% filter (familyID %in% families_filter) %>% column_to_rownames(var = "familyID") %>% select ((final_metadata %>% filter (Response == "Responder")) %>% pull(Sample)) %>% as.matrix()


#model matrix
mm <- model.matrix (~0 + timepoint + tumor_type + ATB_use,  data = (final_metadata %>% filter (Response == "Responder") %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))

#Voom modeling of the data
y <- voom (abundance_prot_families_mt_filter, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(timepointT1 - timepointT2, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
```




###Maaslin2 Analysis 

Maaslin2 analysis is performed for the longitudinal analysis. 
Response and tumor_type are used as fixed effects (important variables that we expect to affect the output)
Patient is used as a mixed effect. 


```{r}
final_metadata_t <- final_metadata %>% t() %>% as.tibble() %>% add_column( variable = colnames(final_metadata), .before = 1 ) %>% row_to_names((row_number = 1))


abundance_prot_families_t <- abundance_prot_families_mt %>% t() %>% as.tibble(rownames = "Sample")

abundance_prot_families_t <- abundance_prot_families_t %>% select (families_filter)

abundance_prot_families_t$Sample <- abundance_prot_families %>% select (contains("DRUP")) %>% colnames()
abundance_prot_families_t <- abundance_prot_families_t %>% relocate (Sample)


saveRDS(abundance_prot_families_t, "./R_objects/abundance_prot_families_t.rds")
saveRDS(final_metadata, "./R_objects/final_metadata.rds")

final_metadata

'''
Maaslin2( 
  input_data = abundance_prot_families_t,
  input_metadata = final_metadata, 
  output = "./maaslin2.2",
  min_prevalence = 0.25 ,
  normalization = "TSS", 
  transform = "LOG", 
  cores = 8, 
  random_effects = c ("timepoint", "patientId"), 
  fixed_effects = c ( "Response", "tumor_type"),
  reference = c ("Response,Responder")
  )
'''

```
Had to interrupt the run when it was generation the boxplots. (not all of them were generated...)


```{r}
maaslin2_results <- read_tsv("./maaslin2.3/all_results.tsv")
maaslin2_results <- maaslin2_results %>% filter (metadata == "Response")

maaslin2_results$qval<-p.adjust(maaslin2_results$pval, method = 'BH') # FDR correction using 'BH'

## Addition of LogFC column (necessary to add pseudocounts)
homology_abun_per_sample3 <- homology_abun_per_sample3 %>% mutate (logFC = log ((mean_abun_non_responders+0.0001)/(mean_abun_responders+0.0001)))


# maaslin2_results %>% arrange (pval)
# homology_abun_per_sample3 %>% filter (familyID == "Cluster_312846") %>% select (-contains ("DRUP"))

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp


vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10)))  +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (qval < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (qval < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

ggsave("Maaslin2_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)

maaslin2_results <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC))

```
This is the volcano plot comming from the TSS normalization and log2 transformation of the data. Doesn't look that bad. 

Look into the proteins differentially expressed to see if there are any with kegg KO annotations
```{r}
maaslin2_results %>% filter (qval <= 0.1)
homology_abun_per_sample3 %>% filter (familyID %in% (maaslin2_results %>% filter (qval <= 0.1) %>% pull(feature))) %>% filter (KEGG_KOs != NaN) %>% select (familyID, KEGG_KOs)
```
0 proteins with KEGG annotation are differentially expressed.. 



#####Top Go analysis: 

Enriched in non-responders
```{r}




# Save the GO_terms from the protein families used for the limma-voom analysis. 
homology_abun_per_sample3 %>% filter (go_terms != NaN) %>% filter (familyID %in% maaslin2_results$familyID) %>%  select (familyID, go_terms) %>% mutate (go_terms = str_replace_all(go_terms, ";", ", ")) %>%  write_tsv(., "./R_objects/SC_GO_terms.tsv" )


# Read the Go_terms with the appropiate function 
geneID2GO <- readMappings( file = "./R_objects/SC_GO_terms.tsv")




## Creation of the gene list with 1 if adjusted pval < 0.05 and 0 otherwise. 
gene_list_go <- ifelse ((maaslin2_results$qval < 0.05), 1, 0)
names(gene_list_go) <- maaslin2_results$familyID


GOdata <- new("topGOdata",
        ontology = "BP", # MF, BP or CC
        allGenes = gene_list_go,
        geneSelectionFun = function(x)(x == 1),
        annot = annFUN.gene2GO, gene2GO = geneID2GO)


resultFisher <- runTest(GOdata, algorithm = "elim", statistic = "fisher")


tab <- GenTable(GOdata, raw.p.value = resultFisher, topNodes = length(resultFisher@score),
                numChar = 120)


```
t-test to each go term can be performed to check if it is present more time in the different 

Go-enrichment plot
```{r}

## Make go enrichment plot: 
tab <- tab %>% mutate (raw.p.value = as.numeric(raw.p.value), term2 = paste(Term, GO.ID, sep = "/")) %>% as_tibble

tab %>% filter (Annotated > 4) %>% head(n = 20) %>%
  ggplot( aes(x=-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_col(aes(fill = "Red"), show.legend = FALSE) + 
  ylab("Biological process") +
  xlab("Enrichment") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )



tab %>% filter (Significant > 2 & raw.p.value < 0.1) %>% head(n = 20) %>%
  ggplot(aes(x =-log10(raw.p.value), y=fct_reorder(Term, raw.p.value, .desc = TRUE))) +
  geom_segment(aes(x = 0, xend = -log10(raw.p.value), y = fct_reorder(Term, raw.p.value, .desc = TRUE), yend = fct_reorder(Term, raw.p.value, .desc = TRUE), color = Significant/Expected), show.legend = FALSE) +
  geom_point (aes(size = Significant * 1.5, color = Significant/Expected))+
  ylab("Biological process") +
  xlab(expression("-log"[10]*"Pval")) +
  labs(color = "Enrichment", size = "Number proteins") +
  #scale_color_continuous(trans = "log", breaks = c(1,2,4,8,16) ) +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    text = element_text(size = 16)
  )

```






####-Heatmap Maaslin2
```{r}

####Heatmap top 50 supervised

#Construction of the heatmap df
heatmap_df <- homology_abun_per_sample3 %>%
  filter (familyID %in% (maaslin2_results %>% arrange(pval) %>% head(n=40) %>% pull(feature))) %>%
  pivot_longer(cols = contains("DRUP0"), names_to = "Sample", values_to = "cpm") %>%
  left_join(., (final_metadata %>%
                  select (Sample, Response, timepoint))) %>%
  replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>%
  rename (TM_domain = denovo_transmembrane, Signaling_domain = denovo_signaling) %>%
  mutate (TM_domain = replace (TM_domain, TM_domain == "Denovo_transmembrane", "Yes"), Signaling_domain = replace (Signaling_domain, Signaling_domain == "Denovo_signaling", "Yes")) 


# #Construction of the heatmap
# 
# heatmap_df %>% replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>% rename ("Protein family" = "familyID") %>%
#   mutate (z_score = log2(cpm+0.01)) %>% ### Normalize the abundance
#   group_by (Response) %>% 
#   heatmap (`Protein family`, Sample, z_score,
#            scale = "row",
#            #show_row_dend = FALSE,
#            show_column_dend = FALSE,
#            show_column_names = FALSE,
#            #palette_grouping = list(c ("black", "grey30")),
#            heatmap_width = unit(10, "npc"),
#            heatmap_height = unit (15, "npc"),
#            row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>%
#   annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
#   annotation_tile (Signaling_domain, palette = c("Yellowgreen", "Gray")) %>%
#   annotation_tile (homology) %>% 
#   annotation_tile(TM_domain, palette = c("Gray", "Yellowgreen"), annotation_name_gp = gpar (fontface = "bold"))  %>%
#   annotation_tile (Response) %>% 
#   as_ComplexHeatmap() %>%
#     ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")





#Construction of the heatmap (filtering only for T1 samples)
heatmap_df %>% replace_na (list (denovo_signaling = "No", denovo_transmembrane = "No")) %>% rename ("Protein family" = "familyID") %>% 
  mutate (z_score = log2(cpm+0.01)) %>% group_by (Response) %>%
  heatmap (`Protein family`, Sample, z_score,
           scale = "row",
           #show_row_dend = FALSE,
           show_column_dend = FALSE,
           show_column_names = FALSE,
           #palette_grouping = list(c ("black", "grey30")),
           heatmap_width = unit(10, "npc"),
           heatmap_height = unit (15, "npc"),
           row_labels = (heatmap_df %>% group_by (familyID) %>% summarise (pro_name = unique (protein_name)) %>% pull (pro_name))) %>%
  annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
  annotation_tile (Signaling_domain, palette = c("blueviolet", "lightblue")) %>%
  annotation_tile(TM_domain, palette = c("lightblue", "blueviolet"), annotation_name_gp = gpar (fontface = "bold"))  %>%
  annotation_tile (Response, palette = c("brown4", "olivedrab")) %>% 
   annotation_tile (homology) %>%
  as_ComplexHeatmap() %>%
    ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")



```













###Maaslin2 Analysis CLR
```{r}
maaslin2_results <- read_tsv("./maaslin2.4_clr/all_results.tsv")
maaslin2_results <- maaslin2_results %>% filter (metadata == "Response")

maaslin2_results$qval<-p.adjust(maaslin2_results$pval, method = 'BH') # FDR correction using 'BH'



maaslin2_results %>% arrange (pval)
homology_abun_per_sample3 %>% filter (familyID == "Cluster_312846") %>% select (-contains ("DRUP"))

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
```


### Maaslin2 only SC clusters

SC clusters are the only ones that have GO annotation. 
TSS and log transformation
```{r}
abundance_prot_families_t <- abundance_prot_families_mt %>% t() %>% as.tibble(rownames = "Sample")

##Filter the samples with GO annotation only
abundance_prot_families_t <- abundance_prot_families_t %>%
  select (homology_abun_per_sample3 %>%
            filter(homology == "SC") %>% pull(familyID) )

abundance_prot_families_t$Sample <- abundance_prot_families %>% select (contains("DRUP")) %>% colnames()
abundance_prot_families_t <- abundance_prot_families_t %>% relocate (Sample)

abundance_prot_families_t %>% saveRDS("./R_objects/abundance_SCprot_families_t.rds")

```




```{r}
maaslin2_results <- read_tsv("./maaslin2.6_GO/all_results.tsv")
maaslin2_results <- maaslin2_results %>% filter (metadata == "Response")

maaslin2_results$qval<-p.adjust(maaslin2_results$pval, method = 'BH') # FDR correction using 'BH'



maaslin2_results %>% arrange (pval)
homology_abun_per_sample3 %>% filter (familyID == "Cluster_312846") %>% select (-contains ("DRUP"))

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(pval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp
```





### Maaslin2 only KEGG

```{r}

abundance_prot_families_t <- abundance_prot_families_mt %>% t() %>% as.tibble(rownames = "Sample")

##Filter the samples with KEGG annotation only
abundance_prot_families_t <- abundance_prot_families_t %>%
  select (homology_abun_per_sample3 %>%
            filter(KEGG_KOs != NaN) %>% pull(familyID) )

abundance_prot_families_t$Sample <- abundance_prot_families %>% select (contains("DRUP")) %>% colnames()
abundance_prot_families_t <- abundance_prot_families_t %>% relocate (Sample)


# Maaslin2( 
#   input_data = abundance_prot_families_t,
#   input_metadata = final_metadata, 
#   output = "./maaslin2.5_KEGG",
#   min_prevalence = 0.3 ,
#   normalization = "TSS", 
#   transform = "LOG", 
#   cores = 8, 
#   random_effects = c ("timepoint", "patientId"), 
#   fixed_effects = c ( "Response", "tumor_type", "ATB_use"),
#   reference = c ("Response,Responder")
#   )


```


```{r}
maaslin2_results <- read_tsv("./maaslin2.5_KEGG/all_results.tsv")
maaslin2_results <- maaslin2_results %>% filter (metadata == "Response")

maaslin2_results$qval<-p.adjust(maaslin2_results$pval, method = 'BH') # FDR correction using 'BH'



maaslin2_results %>% arrange (pval)
homology_abun_per_sample3 %>% filter (familyID == "Cluster_312846") %>% select (-contains ("DRUP"))

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

vp <- maaslin2_results%>% rename (familyID = feature) %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(pval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp

```

This volcano plot has a weird shape (maybe something went wrong). 






##Antismash 

```{r}
big_map_results_rpkm <- read_csv("../bgc_detection/output/run1/big_map_mapping/csv-results/BiG-MAP.map.results.RPKM.csv")

View(big_map_results_rpkm)

```


Data preprocess
```{r}
#Rename the columns 
big_map_results_rpkm <- big_map_results_rpkm %>% rename_with(.cols = contains("DRUP"), .fn = function(x) {str_replace(x, pattern = "-clean", "")})

big_map_results_rpkm <- big_map_results_rpkm %>% mutate (cluster_type = str_replace(gene_clusters, "--OS.*", ""), .after = 1) %>% mutate (cluster_type = str_replace (cluster_type, ".*=", ""))

big_map_results_rpkm %>% group_by(cluster_type) %>% summarise (n = n()) %>% arrange (desc(n))



```

###UMAP for the RPKM abundances
```{r}
#Filter for remote homology
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (contains ("DRUP")) %>% as.matrix() %>% t() %>% clr()


umap_abundance <- umap (as.matrix(abundance_bgc))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Timepoint
umap_plot2 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = timepoint)) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Batch
umap_plot3 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Batch)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Tumor_type
umap_plot4 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = tumor_type)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Clinical Benefit
umap_plot7 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = CB)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


umap_plot1
umap_plot2
umap_plot3
umap_plot4
umap_plot5
umap_plot6
umap_plot7



#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


```
The UMAPS don't show agrupation of the patiends depending on their responds, however they show of the samples with ATB use together. 

###Limma
Differential abundance analysis for the bgc detected. 
```{r}


big_map_results_rpkm_matrix <- big_map_results_rpkm %>%
  mutate (mean = (big_map_results_rpkm %>% select(contains( "DRUP")) %>% rowMeans()), .after = 2 ) %>%  filter (mean > 15) %>% column_to_rownames(var = "gene_clusters") %>%  select(contains( "DRUP")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + patientId ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp





```
```{r}
top.table
```

```{r}

big_map_results_rpkm_group <- big_map_results_rpkm %>% group_by (cluster_type) %>% summarise_if(is_numeric, sum)


big_map_results_rpkm %>% group_by (cluster_type) %>% summarise_if(is_numeric, sum) %>%
  mutate (mean = (. %>% select(contains( "DRUP")) %>% rowMeans()), .after = 2 )

big_map_results_rpkm %>% filter (cluster_type == "terpene") %>% View()


```

```{r}

#Definition of the data frame with the grouping
big_map_results_rpkm_group <- big_map_results_rpkm %>% group_by (cluster_type) %>% summarise_if(is_numeric, sum)

big_map_results_rpkm_matrix <- big_map_results_rpkm_group %>%
  mutate (mean = (big_map_results_rpkm_group %>% select(contains( "DRUP")) %>% rowMeans()), .after = 2 ) %>%
  filter (mean > 50) %>% column_to_rownames(var = "cluster_type") %>%
  select(contains( "DRUP")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + patientId ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
  geom_point(size = 2/5) +
    geom_text_repel(data = . %>% filter (P.Value < 0.05), aes ())
  
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp




```
```{r}
top.table
```






##Antismash all samples (only bgcs first clusters)

```{r}
big_map_results_rpkm <- read_csv("../bgc_detection/output/run2/big_map_mapping/csv-results/BiG-MAP.map.results.RPKM.csv")

View(big_map_results_rpkm)

```


Data preprocess
```{r}
#Rename the columns 
big_map_results_rpkm <- big_map_results_rpkm %>% rename_with(.cols = contains("DRUP"), .fn = function(x) {str_replace(x, pattern = "-clean", "")})

## Add cluster_type column
big_map_results_rpkm <- big_map_results_rpkm %>% mutate (cluster_type = str_replace(gene_clusters, "--OS.*", ""), .after = 1) %>% mutate (cluster_type = str_replace (cluster_type, ".*=", ""))

big_map_results_rpkm %>% group_by(cluster_type) %>% summarise (n = n()) %>% arrange (desc(n))



```

###UMAP for the RPKM abundances
```{r}
#Filter for remote homology
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (contains ("DRUP")) %>% as.matrix() %>% t() %>% clr()


umap_abundance <- umap (as.matrix(abundance_bgc))

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Timepoint
umap_plot2 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = timepoint)) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Batch
umap_plot3 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Batch)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Tumor_type
umap_plot4 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = tumor_type)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Clinical Benefit
umap_plot7 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = CB)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


umap_plot1
umap_plot2
umap_plot3
umap_plot4
umap_plot5
umap_plot6
umap_plot7



#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


```
The UMAPS don't show agrupation of the patiends depending on their responds, however they show of the samples with ATB use together. 

###Limma
Differential abundance analysis for the bgc detected. 
```{r}


big_map_results_rpkm_matrix <- big_map_results_rpkm %>%
  mutate (mean = (big_map_results_rpkm %>% select(contains( "DRUP")) %>% rowMeans()), .after = 2 ) %>%  filter (mean > 15) %>% column_to_rownames(var = "gene_clusters") %>%  select(contains( "DRUP")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + patientId ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp





```
```{r}
top.table
```


###Group by clusters type: 
```{r}

#Definition of the data frame with the grouping
big_map_results_rpkm_group <- big_map_results_rpkm %>% group_by (cluster_type) %>% summarise_if(is_numeric, sum)

## Add column of prevalence: 
big_map_results_rpkm_group["prevalence"] <- rowSums (big_map_results_rpkm_group %>% select (contains ("DRUP")) > 0) / (dim (big_map_results_rpkm_group)[2] -1)


big_map_results_rpkm_matrix <- big_map_results_rpkm_group %>%
  mutate (mean = (big_map_results_rpkm_group %>% select(contains( "DRUP")) %>% rowMeans()), .after = 2 ) %>%
  filter (mean > 50 & prevalence > 0.3) %>% column_to_rownames(var = "cluster_type") %>%
  select(contains( "DRUP")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + patientId ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
  geom_point(size = 2/5) +
    geom_text_repel(data = . %>% filter (P.Value < 0.05), aes ())+
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp




```




```{r}
top.table
big_map_results_rpkm_group
```






```{r}

big_map_results_rpkm_group %>% select (cluster_type, prevalence)

```






##Antismash all samples

```{r}
big_map_results_rpkm <- read_csv("../bgc_detection/output/run3/big_map_mapping/csv-results/BiG-MAP.map.results.RPKM.csv")

View(big_map_results_rpkm)

path_plots_antismash <- "../plots/antismash/"
```


Data preprocess
```{r}
#Rename the columns 
big_map_results_rpkm <- big_map_results_rpkm %>% rename_with(.cols = contains("DRUP"), .fn = function(x) {str_replace(x, pattern = "-clean", "")})

## Add cluster_type column
big_map_results_rpkm <- big_map_results_rpkm %>% mutate (cluster_type = str_replace(gene_clusters, "--OS.*", ""), .after = 1) %>% mutate (cluster_type = str_replace (cluster_type, ".*=", ""))

big_map_results_rpkm %>% group_by(cluster_type) %>% summarise (n = n()) %>% arrange (desc(n))



```

###UMAP for the RPKM abundances
```{r}
#Filter for remote homology
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (contains ("DRUP")) %>% as.matrix() %>% t() %>% clr()

set.seed(5)
umap_abundance <- umap (as.matrix(abundance_bgc), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#Response
umap_plot1 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Timepoint
umap_plot2 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = timepoint)) +
  #ggtitle ("UMAP protein clusters abundance")
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Batch
umap_plot3 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Batch)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#Tumor_type
umap_plot4 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = tumor_type)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Patient ID
umap_plot5 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point(aes (color = patientId), show.legend = FALSE) +
  geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = patientId), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))



#Antibiotics use
umap_plot6 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#BOR
umap_plot7 <- umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = BOR)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16)) +
  scale_color_manual(values = c("PD" = "red", "PR" = "lightblue3", "CR" = "green", "SD" = "orange"))


umap_plot1
umap_plot2
umap_plot3
umap_plot4
umap_plot5
umap_plot6
umap_plot7


#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


```



```{r}

#Responders with lines joining the two timepoints and clusters depending on the response
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  stat_ellipse(data = (umap_df %>% filter (Response == "Responder")), aes(color = Response), linetype = "dashed") +
  stat_ellipse(data = (umap_df %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
ggsave ("umap_response_lines_elipses.png", path = path_plots_antismash, width = 6, height = 4)




#UMAP responders
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  # stat_ellipse(data = (umap_df %>% filter (Response == "Responder")), aes(color = Response), linetype = "dashed") +
  # stat_ellipse(data = (umap_df %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


ggsave ("umap_response_lines.png", path = path_plots_antismash, width = 6, height = 4)


#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))
ggsave ("umap_atb_lines.png", path = path_plots_antismash, width = 6, height = 4)



```


T1 and T2 UMAPs
```{r}

#T1
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (contains ("DRUP") & contains("T1")) %>% as.matrix() %>% t() %>% clr()

set.seed(5)
umap_abundance <- umap (as.matrix(abundance_bgc), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 



#UMAP responders
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#UMAP atb_use
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use, shape = timepoint)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = BOR)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16)) +
  scale_color_manual(values = c("PD" = "red", "PR" = "lightblue3", "CR" = "green", "SD" = "orange"))




#T2 UMAPS
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (contains ("DRUP") & contains("T2")) %>% as.matrix() %>% t() %>% clr()

set.seed(5)
umap_abundance <- umap (as.matrix(abundance_bgc), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 



#UMAP responders
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#UMAP atb_use
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = ATB_use, shape = timepoint)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = BOR)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16)) +
  scale_color_manual(values = c("PD" = "red", "PR" = "lightblue3", "CR" = "green", "SD" = "orange"))




###Clustering removing the samples treated with antibiotics

#Filter for remote homology
abundance_bgc <- big_map_results_rpkm %>% column_to_rownames("gene_clusters") %>% select (final_metadata %>% filter (ATB_use == "No") %>% pull(Sample)) %>% as.matrix() %>% t() %>% clr()

set.seed(5)
umap_abundance <- umap (as.matrix(abundance_bgc), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)


#UMAP responders
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  # stat_ellipse(data = (umap_df %>% filter (Response == "Responder")), aes(color = Response), linetype = "dashed") +
  # stat_ellipse(data = (umap_df %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
ggsave ("umap_response_lines.png", path = path_plots_antismash, width = 6, height = 4)


umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = BOR)) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16)) +
  scale_color_manual(values = c("PD" = "red", "PR" = "lightblue3", "CR" = "green", "SD" = "orange"))


```

###Heatmap

```{r}

#Heatmap of all predicted bgc. 
big_map_results_rpkm_longer <- abundance_bgc %>% t() %>% as_tibble() %>% add_column(gene_clusters =colnames(abundance_bgc)) %>%
pivot_longer (cols = contains ("DRUP"), names_to = "Sample", values_to = "rpkm") %>% 
left_join(., final_metadata %>% select (Sample, Response, timepoint, BOR))


#Construction of the heatmap (filtering only for T1 samples)
big_map_results_rpkm_longer %>%
heatmap (gene_clusters, Sample, rpkm,
         #scale = "row",
         show_row_dend = FALSE,
         # show_column_dend = FALSE,
         show_column_names = FALSE,
         show_row_names = FALSE,
         #palette_grouping = list(c ("black", "grey30")),
         heatmap_width = unit(10, "npc"),
       heatmap_height = unit (15, "npc")) %>% 
  #split_columns(2) %>% 
annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
annotation_tile (Response)   %>% 
  as_ComplexHeatmap() %>%
  ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")


#Using raw data
big_map_results_rpkm_longer <- abundance_bgc %>% t() %>% as_tibble() %>% add_column(gene_clusters =colnames(abundance_bgc)) %>%
pivot_longer (cols = contains ("DRUP"), names_to = "Sample", values_to = "rpkm") %>% 
left_join(., final_metadata %>% select (Sample, Response, timepoint, BOR))


#Construction of the heatmap (filtering only for T1 samples)
big_map_results_rpkm_longer %>%
heatmap (gene_clusters, Sample, rpkm,
         scale = "row",
         show_row_dend = FALSE,
         # show_column_dend = FALSE,
         show_column_names = FALSE,
         show_row_names = FALSE,
         #palette_grouping = list(c ("black", "grey30")),
         heatmap_width = unit(10, "npc"),
         heatmap_height = unit (15, "npc")) %>% 
annotation_tile (timepoint , palette = c ("turquoise", "olivedrab")) %>%
annotation_tile (BOR)
# as_ComplexHeatmap() %>%
#   ComplexHeatmap::draw(heatmap_legend_side = "bottom" , annotation_legend_side="bottom")
```






###Limma

#### ~ response + tumor_type + ATB_use + patientId
Differential abundance analysis for the bgc detected. 
```{r}

##Filter the clusters
big_map_results_rpkm_matrix <- big_map_results_rpkm %>%
  mutate (mean = (big_map_results_rpkm %>% select(contains( "DRUP")) %>% rowMeans()), prevalence = rowSums (big_map_results_rpkm %>% select (contains ("DRUP")) > 0) / (dim (big_map_results_rpkm %>% select (contains("DRUP")))[2]),.after = 2 ) %>%  filter (mean > 40 & prevalence > 0.4) %>% column_to_rownames(var = "gene_clusters") %>%  select(contains( "DRUP")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + patientId + timepoint ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp





```
```{r}
big_map_results_rpkm %>% select (contains ("DRUP")) %>% colSums()
```



#### T1
Differential abundance analysis for the bgc detected. 
```{r}

##Filter the clusters
big_map_results_rpkm_matrix <- big_map_results_rpkm %>% select (-contains ("T2")) %>% 
  mutate (mean = (big_map_results_rpkm %>% select(contains( "DRUP")) %>% rowMeans()), prevalence = rowSums (big_map_results_rpkm %>% select (contains ("DRUP")) > 0) / (dim (big_map_results_rpkm %>% select (contains("DRUP")))[2]),.after = 2 ) %>%  filter (mean > 40 & prevalence > 0.4) %>% column_to_rownames(var = "gene_clusters") %>%  select(contains( "T1")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("T1")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table

vp <- top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point() +
    geom_point (size = 6/5,data = . %>% filter (adj.P.Val < 0.1 & logFC > 1), aes(color = cluster_type, size = 2/5)) +
    geom_point (size = 6/5, data = . %>% filter (adj.P.Val < 0.1 & logFC < -1), aes(color = cluster_type, size = 2/5))+
    theme_bw() +
    theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  #geom_text_repel(data = . %>% filter (adj.P.Val < 0.1), aes(label = cluster_type))+
    ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T1)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) +
  geom_hline (yintercept = -log(0.1, 10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp
top.table_t1 <- top.table

ggsave ("volcano_limma_T1_response_tumor_type_atb_use.png", path = path_plots_antismash, width = 8, height = 4)


vp <- top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) +
  geom_hline (yintercept = -log(0.1, 10), linetype = "dashed", alpha = 0.3)  + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp


write_tsv (top.table %>% rownames_to_column(var = "ID") , "./R_objects/antismash_bgc_DA_T1.tsv")







```


```{r}
top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type))
```





#### T2
Differential abundance analysis for the bgc detected. 
```{r}

##Filter the clusters
big_map_results_rpkm_matrix <- big_map_results_rpkm %>% select (-contains ("T1")) %>% 
  mutate (mean = (big_map_results_rpkm %>% select(contains( "DRUP")) %>% rowMeans()), prevalence = rowSums (big_map_results_rpkm %>% select (contains ("DRUP")) > 0) / (dim (big_map_results_rpkm %>% select (contains("DRUP")))[2]),.after = 2 ) %>%  filter (mean > 40 & prevalence > 0.4) %>% column_to_rownames(var = "gene_clusters") %>%  select(contains( "T2")) %>% as.matrix()
 


#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("T2")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table_t2 <- top.table

vp <- top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point() +
    geom_point (size = 6/5,data = . %>% filter (adj.P.Val < 0.1 & logFC > 1), aes(color = cluster_type, size = 2/5)) +
    geom_point (size = 6/5, data = . %>% filter (adj.P.Val < 0.1 & logFC < -1), aes(color = cluster_type, size = 2/5))+
    theme_bw() +
    theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  #geom_text_repel(data = . %>% filter (adj.P.Val < 0.1), aes(label = cluster_type), max.overlaps = Inf)+
    ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders at T2)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) +
  geom_hline (yintercept = -log(0.1, 10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)

vp

ggsave ("volcano_limma_T2_response_tumor_type_atb_use.png", path = path_plots_antismash, width = 9, height = 4)


vp <- top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type)) %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) +
  geom_hline (yintercept = -log(0.1, 10), linetype = "dashed", alpha = 0.3)  + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp


write_tsv (top.table %>% rownames_to_column(var = "ID"), "./R_objects/antismash_bgc_DA_T2.tsv")


```
```{r}
top.table %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type))

top.table_t1$timepoint <- rep("T1", dim(top.table_t1)[1])
top.table_t2$timepoint <- rep("T2", dim(top.table_t2)[1])

top.table_t1 <- top.table_t1 %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type))

top.table_t2 <- top.table_t2 %>% rownames_to_column(var = "gene_clusters") %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type))


bind_rows(top.table_t1, top.table_t2) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 0.8 ) +
    geom_point (size = 1.5, data = . %>% filter (adj.P.Val < 0.1 & logFC > 1), aes(color = cluster_type)) +
    geom_point (size = 1.5,  data = . %>% filter (adj.P.Val < 0.1 & logFC < -1), aes(color = cluster_type))+
    theme_bw() +
    theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  #geom_text_repel(data = . %>% filter (adj.P.Val < 0.1), aes(label = cluster_type), max.overlaps = Inf)+
    ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) +
  geom_hline (yintercept = -log(0.1, 10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3) +
  facet_grid(.~timepoint)

ggsave ("volcano_limma_T1-T2_response_tumor_type_atb_use.png", path = path_plots_antismash, width = 12, height = 4)



vp

```



#### Maaslin2

```{r}

big_map_results_rpkm_t <- big_map_results_rpkm %>% column_to_rownames(var = "gene_clusters") %>% select (contains ("DRUP")) %>% as.matrix() %>% t() %>% as.tibble(rownames = "Sample")


Maaslin2(
  input_data = big_map_results_rpkm_t,
  input_metadata = final_metadata,
  output = "./maaslin2.7_antismash",
  min_prevalence = 0.3 ,
  normalization = "TSS",
  transform = "LOG",
  cores = 8,
  random_effects = c ("timepoint", "patientId"),
  fixed_effects = c ( "Response", "tumor_type", "ATB_use"),
  reference = c ("Response,Responder")
  )


```


```{r}
maaslin2_results <- read_tsv("./maaslin2.7_antismash/all_results.tsv")
maaslin2_results <- maaslin2_results %>% filter (metadata == "Response")

maaslin2_results$qval<-p.adjust(maaslin2_results$pval, method = 'BH') # FDR correction using 'BH'

## Addition of LogFC column (necessary to add pseudocounts)
big_map_results_rpkm$mean_abun_responders <- big_map_results_rpkm %>% select (final_metadata %>% filter (Response == "Responder") %>% pull(Sample)) %>% rowMeans()
big_map_results_rpkm$mean_abun_non_responders <- big_map_results_rpkm %>% select (final_metadata %>% filter (Response == "Non-responder") %>% pull(Sample)) %>% rowMeans()

big_map_results_rpkm <- big_map_results_rpkm %>% mutate (logFC = log ((mean_abun_non_responders+0.0001)/(mean_abun_responders+0.0001)))


# maaslin2_results %>% arrange (pval)
# homology_abun_per_sample3 %>% filter (familyID == "Cluster_312846") %>% select (-contains ("DRUP"))

vp <- maaslin2_results%>% rename (gene_clusters = feature) %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10))) +
    geom_point(size = 2/5) +
    theme_bw()
    
vp


vp <- maaslin2_results%>% rename (gene_clusters = feature) %>% left_join(., big_map_results_rpkm %>% select (gene_clusters, cluster_type, logFC)) %>% 
  ggplot (aes (x = logFC, y = -log(qval,10)))  +
    geom_point(size = 2/5) +
    geom_point (data = . %>% filter (qval < 0.05 & logFC > 1), color = "red", size = 2/5, show.legend = FALSE) +
  geom_point (data = . %>% filter (qval < 0.05 & logFC < -1), color = "red", size = 2/5, show.legend = FALSE) +
    theme_bw() +
  theme (
    text = element_text(size = 14), 
    panel.border = element_rect(color = "black"), 
    panel.grid = element_blank(),
  )+
  ylab("-log10(Adj.P.Val)") +
  xlab ("logFC (Non-responders/Responders)")+
  geom_hline (yintercept = -log(0.05,10), linetype = "dashed", alpha = 0.3) + 
  geom_vline( xintercept = -1, linetype = "dashed", alpha = 0.3)+
  geom_vline( xintercept = 1, linetype = "dashed", alpha = 0.3)
vp

#ggsave("Maaslin2_response_tumortype_atb_use.png", path = path_plots, height = 4, width = 6)



```














###Group by clusters type: 


Create the groups: 
```{r}
#Definition of the data frame with the grouping
big_map_results_rpkm_group <- big_map_results_rpkm %>% group_by (cluster_type) %>% summarise_if(is_numeric, sum)

big_map_results_rpkm_group <- big_map_results_rpkm_group %>% left_join (., (big_map_results_rpkm %>% group_by(cluster_type) %>% summarise (n = n()))) %>% relocate(n, .after = 1)
```


```{r}
big_map_results_rpkm_group %>% select (cluster_type, n) %>% mutate (per = round(n*100/sum(n),2)) %>% arrange (desc(n))%>% filter (!str_detect(cluster_type, ":"))

big_map_results_rpkm_group %>% mutate (mean_abun = rowMeans(big_map_results_rpkm_group %>% select (contains ("DRUP")))) %>% mutate (per_mean = round(mean_abun*100/sum(mean_abun),2), per = round(n*100/sum(n),2)) %>% select (cluster_type, n, per, per_mean) %>% arrange (desc(n)) %>% View()



###Add the dual clustes individually to each individual group. 
big_map_results_rpkm_group <- big_map_results_rpkm_group %>% filter (str_detect(cluster_type, ":", negate = TRUE)) %>% 
  bind_rows(.,(
    big_map_results_rpkm_group %>% filter (str_detect(cluster_type, ":" )) %>% mutate(cluster_type = str_replace(cluster_type, ":.*", ""))
)) %>% 
  bind_rows (., (
    big_map_results_rpkm_group %>% filter (str_detect(cluster_type, ":" )) %>% mutate(cluster_type = str_replace(cluster_type, ".*:", ""))
  )) %>%
  group_by(cluster_type) %>% summarise_if(is_numeric, sum)
  
```

```{r}


#Filter for remote homology
abundance_bgc <- big_map_results_rpkm_group %>% column_to_rownames("cluster_type") %>% select (contains ("DRUP")) %>% as.matrix() %>% t() %>% clr()


umap_abundance <- umap (as.matrix(abundance_bgc), preserve.seed = TRUE)

umap_df <- umap_abundance$layout %>% as_tibble() %>%  rename("UMAP1"="V1", "UMAP2"="V2") %>% add_column (Sample = rownames (umap_abundance$layout), .before = 1) %>% inner_join(., (final_metadata %>% select (c("Sample", "Response", "patientId", "timepoint", "Batch", "tumor_type", "BOR", "CB", "ATB_use") ))) 

umap_mean_sample <- umap_df %>% group_by(patientId) %>% summarise (x = mean(UMAP1), y = mean (UMAP2)) %>% mutate (, Id_num = as.numeric(factor (.$patientId)))
umap_df <- umap_df %>% left_join (., umap_mean_sample)




#Responders with lines joining the two timepoints and clusters depending on the response
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  stat_ellipse(data = (umap_df %>% filter (Response == "Responder")), aes(color = Response), linetype = "dashed") +
  stat_ellipse(data = (umap_df %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))

#UMAP responders
umap_df %>% ggplot (aes (x = UMAP1, y = UMAP2)) + geom_point( aes (color = Response, shape = timepoint)) +
  #xlab (paste0("UMAP1 (",round(100 * pca_abundance$sdev[1] ** 2 / sum (pca_abundance$sdev **2), 2),"%)"))+
  #ylab (paste0("UMAP2 (",round(100 * pca_abundance$sdev[2] ** 2 / sum (pca_abundance$sdev **2), 2),"%)")) +
  #ggtitle ("UMAP protein clusters abundance")
  # stat_ellipse(data = (umap_df %>% filter (Response == "Responder")), aes(color = Response), linetype = "dashed") +
  # stat_ellipse(data = (umap_df %>% filter (Response == "Non-responder")), aes(color = Response), linetype = "dashed") +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = Response), show.legend = FALSE, alpha = 0.4) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))


#Umap with line joining patients at different timepoints colured depending on the antibiotic use. 
ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use %in% c("Yes", "Unknown")), "Antibioitic / unknown use", "no_antibiotic_use"))

ATB_use_sample <- umap_df %>% group_by(patientId) %>% summarize (ATB_use_sample = ifelse(any (ATB_use == "Yes"), "Yes", ifelse(any (ATB_use == "Unknown"), "Unknown", "No")))

#Patient ID
umap_df %>% left_join(.,ATB_use_sample) %>%  ggplot (aes (x = UMAP1, y = UMAP2)) + 
  geom_point( show.legend = TRUE, aes (shape = timepoint, color = ATB_use)) +
  #geom_text_repel(data = umap_mean_sample, aes (x = x, y = y, label = Id_num), size = 3) +
  #geom_point (aes (x = x, y = y, color = patientId), show.legend = FALSE) +
  geom_segment(aes(x = x, y = y, xend = UMAP1, yend = UMAP2, color = ATB_use_sample), alpha = 0.8) +
  theme_bw() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank(), text = element_text(size = 16))
  #theme(text = element_text(size=12))


```



#### ~ response + tumor_type + ATB_use + timepoint + patientId
```{r}


## Filter the clusters by prevalence and mean: 
big_map_results_rpkm_matrix <- big_map_results_rpkm_group %>%
  mutate (
    mean = (big_map_results_rpkm_group %>% select(contains( "DRUP")) %>% rowMeans()),
    prevalence = rowSums (big_map_results_rpkm_group %>% select (contains ("DRUP")) > 0 ) / (dim(big_map_results_rpkm_group)[2] -1),
    .after = 2 ) %>%
  filter (mean > 50 & prevalence > 0.5) %>% filter (str_detect(cluster_type, ":", negate = TRUE )) %>% column_to_rownames(var = "cluster_type") %>%
  select(contains( "DRUP")) %>% as.matrix()
 

  
#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use + timepoint + patientId,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("DRUP")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point(size = 2/5) +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
  geom_point(size = 2/5) +
    geom_text_repel(data = . %>% filter (P.Value < 0.1), aes (label = cluster_id))+
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp




```




#### T1 only 
```{r}

## Filter the clusters by prevalence and mean: 
big_map_results_rpkm_matrix <- big_map_results_rpkm_group %>%
  select (-contains ("T2")) %>% 
  mutate (
    mean = (big_map_results_rpkm_group %>% select(contains( "DRUP")) %>% rowMeans()),
    prevalence = rowSums (big_map_results_rpkm_group %>% select (contains ("DRUP")) > 0 ) / (dim(big_map_results_rpkm_group)[2] -1),
    .after = 2 ) %>%
  filter (mean > 50 & prevalence > 0.5) %>% filter (str_detect(cluster_type, ":", negate = TRUE )) %>% column_to_rownames(var = "cluster_type") %>%
  select(contains( "DRUP")) %>% as.matrix()
 



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("T1")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf, adjust.method = "fdr")

top.table

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point() +
  geom_text_repel(data = . %>% filter (logFC > 0.5 |logFC < -0.5), aes (label = cluster_id))+
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
  geom_point() +
    geom_text_repel(data = . %>% filter (logFC > 0.5 |logFC < -0.5), aes (label = cluster_id))+
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

write_tsv (top.table %>% rownames_to_column(var = "ID"), "./R_objects/antismash_bgc_clusters_DA_T1.tsv")


```


#### T2 only 
```{r}

## Filter the clusters by prevalence and mean: 
big_map_results_rpkm_matrix <- big_map_results_rpkm_group %>%
  select (-contains ("T1")) %>% 
  mutate (
    mean = (big_map_results_rpkm_group %>% select(contains( "DRUP")) %>% rowMeans()),
    prevalence = rowSums (big_map_results_rpkm_group %>% select (contains ("DRUP")) > 0 ) / (dim(big_map_results_rpkm_group)[2] -1),
    .after = 1 ) %>%
  filter (mean > 50 & prevalence > 0.5) %>%  filter (str_detect(cluster_type, ":", negate = TRUE )) %>% column_to_rownames(var = "cluster_type") %>%
  select(contains( "DRUP")) %>% as.matrix()
 



#model matrix
mm <- model.matrix (~0 + Response + tumor_type + ATB_use ,  data = (final_metadata %>% filter (Sample %in% (big_map_results_rpkm %>% select (contains ("T2")) %>% colnames())) %>% mutate (Response = make.names(Response), tumor_type = make.names(tumor_type))))



#Voom modeling of the data
y <- voom (big_map_results_rpkm_matrix, mm, plot = T )

#Fitting of the model with Limma
fit <- lmFit(y, mm)

head (coef(fit))

contr <- makeContrasts(ResponseNon.responder - ResponseResponder, levels = colnames(coef(fit)))
#contr <- makeContrasts(response_group_T1Responder - response_group_T1Non.responder, levels = colnames(coef(fit)))

#fitting of the contrast
tmp <- contrasts.fit (fit , contr)

#Empirical Bayes smoothing of standard errors 
tmp <- eBayes (tmp)

top.table <- topTable (tmp, sort.by = "P", n = Inf)

top.table

vp <- top.table %>% rownames_to_column(var = "familyID") %>% left_join(., homology_abun_per_sample3 %>% select (familyID, protein_name)) %>% 
  ggplot (aes (x = logFC, y = -log(adj.P.Val,10))) +
    geom_point() +
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp

vp <- top.table %>% rownames_to_column(var = "cluster_id") %>% 
  ggplot (aes (x = logFC, y = -log(P.Value,10))) +
  geom_point() +
  geom_text_repel(data = . %>% filter (logFC > 0.5 |logFC < -0.5), aes (label = cluster_id))+
    theme_bw() +
  geom_hline (yintercept = -log(0.05,10)) +
  geom_hline (yintercept = -log(0.1, 10)) + 
  geom_hline (yintercept = -log( 0.25, 10))
vp


write_tsv (top.table %>% rownames_to_column(var = "ID"), "./R_objects/antismash_bgc_clusters_DA_T2.tsv" )


```









```{r}

final_metadata %>% filter (timepoint == "T1") %>% group_by(tumor_type) %>% summarise (n = n(), per = round(100*n()/76, 2)) %>% arrange(desc(n)) %>% write_csv(., "R_objects/tumor_type_number.csv")


final_metadata %>% filter(timepoint == "T1") %>% group_by (Response) %>% summarise (n = n())
final_metadata %>% filter(timepoint == "T2") %>% group_by (Response) %>% summarise (n = n())



drup_metadata %>% filter (timepoint == "T3")


final_metadata %>% filter (timepoint == "T1") %>% group_by(tumor_type) %>% summarise (n = n(), per = round(100*n()/76, 2), nR = sum(Response == "Responder"), nNR = sum(Response =="Non-responder")) %>% arrange(desc(n))


final_metadata %>% filter (timepoint == "T1") %>% group_by(tumor_groups) %>% summarise (n = n())

homology_abun_per_sample3 %>% filter (n_proteins > 1) %>% mutate (n_proteins = as.numeric(n_proteins)) %>% select (familyID, n_proteins) %>% summary()

homology_abun_per_sample3 %>% filter (homology == "NH") %>% pull(prevalence) %>% median()
homology_abun_per_sample3 %>% select (familyID, prevalence)

```







?? May want to filter the protein clusters with low levels of abundance. This has to be done in RNA-seq /microarray experiments 

"For good results, the counts matrix should be filtered to remove remove rows with very low counts before running voom(). The filterByExpr function in the edgeR package can be used for that purpose."













Needed graphs: 

- Distribution of length of the protein clusters depending on their homology. 
- Number of protein clusters per sample. 
- Why there are more pfam annotations?





